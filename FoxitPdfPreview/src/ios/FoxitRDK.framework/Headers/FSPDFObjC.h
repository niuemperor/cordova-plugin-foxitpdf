/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.6
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

/**
 * @file	FSPDFObjC.h
 * @brief	This file contains definitions of object-c APIs for Foxit PDF SDK.
 */

#import <Foundation/Foundation.h>


#ifdef __cplusplus
extern "C" {
#endif

#import <CoreGraphics/CoreGraphics.h>
@class FSAnnotIconProviderCallback;
@class FSPDFDoc;
@class FSPDFPage;
@class FSPDFTextSelect;
@class FSBorderInfo;
@class FSPDFDictionary;
@class FSPDFObject;
@class FSPDFStream;
@class FSPDFArray;
@class FSNote;
@class FSBitmap;


/**
 * @name	Macro Definitions for Annotation Icon Name
 */
/**@{*/

/** @brief	Note icon name: Checkmark. */
#define FS_ANNOT_ICONNAME_TEXT_CHECKMARK			"Checkmark"
/** @brief	Note icon name: Circle. */
#define FS_ANNOT_ICONNAME_TEXT_CIRCLE				"Circle"
/** @brief	Note icon name: Comment. */
#define FS_ANNOT_ICONNAME_TEXT_COMMENT				"Comment"
/** @brief	Note icon name: Cross. */
#define FS_ANNOT_ICONNAME_TEXT_CROSS				"Cross"
/** @brief	Note icon name: Help. */
#define FS_ANNOT_ICONNAME_TEXT_HELP					"Help"
/** @brief	Note icon name: Insert. */
#define FS_ANNOT_ICONNAME_TEXT_INSERT				"Insert"
/** @brief	Note icon name: Key. */
#define FS_ANNOT_ICONNAME_TEXT_KEY					"Key"
/** @brief	Note icon name: New Paragraph. */
#define FS_ANNOT_ICONNAME_TEXT_NEWPARAGRAPH			"NewParagraph"
/** @brief	Note icon name: Note. */
#define FS_ANNOT_ICONNAME_TEXT_NOTE					"Note"
/** @brief	Note icon name: Paragraph. */
#define FS_ANNOT_ICONNAME_TEXT_PARAGRAPH			"Paragraph"
/** @brief	Note icon name: Right Arrow. */
#define FS_ANNOT_ICONNAME_TEXT_RIGHTARROW			"RightArrow"
/** @brief	Note icon name: Right Pointer. */
#define FS_ANNOT_ICONNAME_TEXT_RIGHTPOINTER			"RightPointer"
/** @brief	Note icon name: Star. */
#define FS_ANNOT_ICONNAME_TEXT_STAR					"Star"
/** @brief	Note icon name: Up Arrow. */
#define FS_ANNOT_ICONNAME_TEXT_UPARROW				"UpArrow"
/** @brief	Note icon name: Up-left Arrow. */
#define FS_ANNOT_ICONNAME_TEXT_UPLEFTARROW			"UpleftArrow"

/**@}*/

/**
 * @brief	Enumeration for rotation.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ROTATION {
	/** @brief	No rotation. */
	e_rotation0 = 0,
	/** @brief	Rotate 90 degrees in clockwise direction. */
	e_rotation90 = 1,
	/** @brief	Rotate 180 degrees in clockwise direction. */
	e_rotation180 = 2,
	/** @brief	Rotate 270 degrees in clockwise direction. */
	e_rotation270 = 3,
	/** @brief	Unknown rotation. */
	e_rotationUnknown = 4
};

/**
 * @brief	Enumeration for progress state.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_PROGRESSSTATE {
	/** @brief	Progress state: any error occurs. */ 
	e_progressError = 0,
	/** @brief	Progress state: progress needs to be continued. */
	e_progressToBeContinued = 1,
	/** @brief	Progress state: progress is finished. */
	e_progressFinished = 2
};

/**
 * @brief	Enumeration for DIB format.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_DIBFORMAT {
	/** @brief	Invalid DIB format. */
	e_dibInvalid = 0,
	/** @brief	DIB format: 24bpp format, with bits order "Blue, Green, Red". Blue is in the lowest order. */
	e_dibRgb = 0x018,
	/** @brief	DIB format: 32bpp format, with bits order "Blue, Green, Red, not used". Blue is in the lowest order. */
	e_dibRgb32 = 0x020,
	/** @brief	DIB format: 32bpp format, with bits order "Blue, Green, Red, Alpha". Blue is in the lowest order. */
	e_dibArgb = 0x220
};

/**
 * @brief	Enumeration for error code.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ERRORCODE {
	/** @brief	Success, and no error occurs. */
	e_errSuccess = 0,
	/** @brief	File error: file cannot be found or could not be opened. */
	e_errFile = 1,
	/** @brief	Format error: format is invalid. For files, this may also mean that file is corrupted. */
	e_errFormat = 2,
	/** 
	 * @brief	Password error: invalid password.
	 *
	 * @details	Usually, this error may occur when loading a PDF document with password. 
	 *			When meet this, user should call function {@link FSPDFDoc::load:} again, with correct password.
	 */
	e_errPassword = 3,
	/** @brief	Handler error: PDF document is encrypted by some unsupported security handler. */
	e_errHandler = 4,
	/** @brief	Certificate error: PDF document is encrypted by digital certificate and current user does not have the correct certificate. */
	e_errCertificate = 5,
	/** @brief	Unknown error: any unknown error occurs. */
	e_errUnknown = 6,
	/** @brief	License error: invalid license is used to initialize Foxit PDF SDK library. */
	e_errInvalidLicense = 7,
	/** @brief	Parameter error: value of any input parameter for a function is invalid. */
	e_errParam = 8,
	/** @brief	Unsupported error: some types are not supported.*/
	e_errUnsupported = 9,
	/** @brief	Memory error: out-of-memory error occurs.*/
	e_errOutOfMemory = 10,
    /** @brief	Security handler error: PDF document is encrypted by some unsupported security handler. */
    e_errSecurityHandler = 11
};

/**
 * @brief	Enumeration for display mode, which specifies how the document should be displayed when opened.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_DISPLAYMODE {
	/** @brief	When document is opened, neither document outlines nor thumbnail images are visible. */
	e_displayUseNone = 0,
	/** @brief	When document is opened, document outlines (bookmarks) are visible. */
	e_displayUseOutlines = 1,
	/** @brief	When document is opened, thumbnail images are visible. */
	e_displayUseThumbs = 2,
	/** @brief	When document is opened, full-screen mode, with no menu bar, window controls, or any other windows are visible. */
	e_displayFullScreen = 3,
	/** @brief	When document is opened, optional content group panels are visible. */
	e_displayUseOC = 4,
	/** @brief	When document is opened, attachment panels are visible. */
	e_displayUseAttatchment = 5
};

/**
 * @brief	Enumeration for zoom mode.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ZOOMMODE {
	/** 
	 * @brief	Display page with a specific position and a specific zoom factor.
	 *
	 * @details	If this is used, that means the specific position of the page will be treated as the left-top position when the page is rendered 
	 *			and this position should be at the upper-left corner of the display area, 
	 *			and the contents of the page should be magnified by the zoom factor.
	 */
	e_zoomXYZ = 1,
	/** 
	 * @brief	Fit the entire page within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit the entire page within the display area both horizontally and vertically. 
	 *			If the required horizontal and vertical magnification factors are different, 
	 *			use the smaller of the two, centering the page within the window in the other dimension.
	 */
	e_zoomFitPage = 2,
	/** 
	 * @brief	Fit the entire width of the page within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit the entire width of the page within the display area.
	 */ 
	e_zoomFitHorz = 3,
	/** 
	 * @brief	Fit the entire height of the page within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit the entire height of the page within the display area.
	 */ 
	e_zoomFitVert = 4,
	/** 
	 * @brief	Fit the page content in a specific rectangle entirely within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit the page content in the specific rectangle entirely within the display area both horizontally and vertically. 
	 *			If the required horizontal and vertical magnification factors are different, 
	 *			use the smaller of the two, centering the rectangle within the display area in the other dimension.
	 */ 
	e_zoomFitRect = 5,
	/** 
	 * @brief	Fit the bounding box of page entirely within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit its bounding box entirely within the display area both horizontally and vertically. 
	 *			If the required horizontal and vertical magnification factors are different, 
	 *			use the smaller of the two, centering the bounding box within the display area in the other dimension.
	 */ 
	e_zoomFitBBox = 6,
	/** 
	 * @brief	Fit the entire width of the page's bounding box within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit the entire width of the page's bounding box within the display area.
	 */ 
	e_zoomFitBHorz = 7,
	/** 
	 * @brief	Fit the entire height of the page's bounding box within the display area when display the page.
	 *
	 * @details	If this is used, that means the contents of the page should be magnified 
	 *			just enough to fit the entire height of the page's bounding box within the display area.
	 */ 
	e_zoomFitBVert = 8
};

/**
 * @brief	Enumeration for module name.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_MODULENAME {
	/** @brief	Standard module. */
	e_moduleNameStandard = 0,
	/** @brief	Annotation module. */
	e_moduleNameAnnotation = 1,
};

/**
 * @brief	Enumeration for module right.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_MODULERIGHT {
	/** @brief	Module right: unknown. */
	e_moduleRightUnknown = -1,
	/** @brief	Module right: no right. */
	e_moduleRightNone = 0,
	/** @brief	Module right: read. */
	e_moduleRightRead = 1,
	/** @brief	Module right: write, including read. */
	e_moduleRightWrite = 2
};

/**
 * @brief	Class to represent a callback object to notify the Foxit PDF SDK events.
 * 
 * @details	All the pure virtual functions in this class are used as callback functions and should be implemented by user. 
 *			An implemented ::FSNotifier object can be set to Foxit PDF SDK by function {@link FSLibrary::setNotifier:}.
 */
@interface FSNotifier : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	A callback function used to be triggered when Foxit PDF SDK runs out of the memory. 
 *
 * @return	None.
 */
-(void)OnOutOfMemory;
/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent the library management for global configuration.
 *
 * @details	It contains functions to initialize/re-initialize/release Foxit PDF SDK library, and also contains functions for global use.<br>
 *			Any application should load Foxit PDF SDK by function {@link FSLibrary::init:key:} before calling any other Foxit PDF SDK functions. 
 *			When there is no need to use Foxit PDF SDK any more, call function {@link FSLibrary::release}.
 */
@interface FSLibrary : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Initialize Foxit PDF SDK Library, with valid license information.
 *
 * @details	This function should be called first before other functions in Foxit PDF SDK can be called.
 * 
 * @param[in]	sn		String of sn information, which can be retrieved from "SN=" part in key file "rdk_sn.txt".
 * @param[in]	key		String of key information, which can be retrieved from "Sign=" part in key file "rdk_key.txt".
 *
 * @return	{@link FS_ERRORCODE::e_errSuccess} means success.
 *			{@link FS_ERRORCODE::e_errInvalidLicense} means input license information is invalid.
 *			{@link FS_ERRORCODE::e_errParam} means parameter <i>sn</i> or <i>key</i> is <b>nil</b> or empty string.
 */
+(enum FS_ERRORCODE)init: (NSString *)sn key: (NSString *)key;
/**
 * @brief	Reinitialize Foxit PDF SDK Library.
 *
 * @details	When user meets out-of-memory error, user can call this function to reinitialize Foxit PDF SDK Library.
 * 
 * @return	{@link FS_ERRORCODE::e_errSuccess} means success.
 *			For more information about error code values, please refer to {@link FS_ERRORCODE::e_errSuccess FS_ERRORCODE::e_errXXX} values.
 */
+(enum FS_ERRORCODE)reinit;
/**
 * @brief	Release all resource allocated by Foxit PDF SDK Library.
 *
 * @details	User can call this function to release all memory blocks allocated by the library. 
 *			After this function is called, user should not call any function of Foxit PDF SDK.
 *
 * @return	None.
 */
+(void)release;
/**
 * @brief	Get the version of current Foxit PDF SDK library.
 *
 * @return	The library version string.
 */
+(NSString*)getVersion;

/**
 * @brief	Get the authority of a specific module.
 *
 * @param[in]	module	Module name. It should be one of {@link FS_MODULENAME::e_moduleNameStandard FS_MODULENAME::e_moduleNameXXX} values.
 *
 * @return	The right of specific module. It would be one of {@link FS_MODULERIGHT::e_moduleRightUnknown FS_MODULENAME::e_moduleRightXXX} values.
 */
+(enum FS_MODULERIGHT)getModuleRight: (enum FS_MODULENAME)module;
/**
 * @brief	Set a customized annotation icon provider to Foxit PDF SDK.
 *
 * @details	User can call this function to set a customized icon provider for annotation. 
 *			If this function has been called several times, Foxit PDF SDK will only keep the last icon provider.
 *			Foxit PDF SDK will use a default standard icon provider if there is no provider been set.
 *
 * @param[in]	iconProvider		Pointer to a customized annotation icon provider, which is implemented based on class ::FSAnnotIconProviderCallback.
 *									If this is <b>nil</b>, customized annotation icon provider will be removed from Foxit PDF SDK and default standard icon provider will be used instead.
 *									Application should ensure this icon provider object valid until it has been removed from Foxit PDF SDK or function {@link FSLibrary::release} is called.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
+(BOOL)setAnnotIconProvider: (FSAnnotIconProviderCallback*)iconProvider;
/**
* @brief	Set a notifier to Foxit PDF SDK.
 *
 * @details	User can call this function to set a notifier to Foxit PDF SDK, so that when SDK events (such as OOM) occurs, user would be notified.
 *
 * @param[in]	notifier	A ::FSNotifier object. User should ensure all the callback functions have been implemented in application level.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
+(BOOL)setNotifier: (FSNotifier*)notifier;

/** @brief Free the object. */
-(void)dealloc;

@end
	
/** @brief	Class represents a recovery manager to recover SDK when out-of-memory error occurs. It will help to clear the memory, free the cache and reload the document. */
@interface FSRecoveryManager : NSObject
/**
 * @brief	Receive a shared instance of recovery manager.
 *
 * @return	The recovery manager instance.
 */
+(FSRecoveryManager*)sharedInstance;
/**
 * @brief	Reload the specified PDF document.
 *
 * @details	When there is an OOM, user may call this function to reload the document.
*			The editing content will not be saved because there is no more memory left.
 *
 * @param[in]	pdfDoc	The PDF document to be reloaded. It will be invalid when the document reloaded.
 *
 * @return	The new document object.
 */
-(FSPDFDoc*) reloadDoc:(FSPDFDoc*)pdfDoc;
@end
	

/************************************************************************************************
 *									Basic data structures or classes							*
 *************************************************************************************************/

/**
 * @brief	Class to represent a point, in floating point.
 */  
@interface FSPointF : NSObject

{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief	X coordinate value, in floating point.*/
@property (nonatomic,assign) float x;
/** @brief	Y coordinate value, in floating point.*/
@property (nonatomic,assign) float y;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value for current point.
 *
 * @param[in]	x	Horizontal coordinate value for the point, in floating point.
 * @param[in]	y	Vertical coordinate value for the point, in floating point.
 * 
 * @return	None.
 */
-(void)set: (float)x y: (float)y;
/** 
 * @brief	Set horizontal coordinate value of the point, in floating point.
 * 
 * @param[in]	value	Value for horizontal coordinate, in floating point.
 *
 * @return	None.
 */
-(void)setX: (float)value;
/** 
 * @brief	Get horizontal coordinate value of the point, in floating point.
 *
 * @return	Horizontal coordinate value, in floating point.
 */
-(float)getX;
/** 
 * @brief	Set vertical coordinate value of the point, in floating point.
 * 
 * @param[in]	value	Value for vertical coordinate, in floating point.
 *
 * @return	None.
 */
-(void)setY: (float)value;
/** 
 * @brief	Get vertical coordinate value of the point, in floating point.
 *
 * @return	Vertical coordinate value, in floating point.
 */
-(float)getY;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent a rectangle, in floating point.
 */
@interface FSRectF : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief	Left coordinate value, in float. */
@property (nonatomic,assign) float left;
/** @brief	Bottom coordinate value, in float. */
@property (nonatomic,assign) float bottom;
/** @brief	Right coordinate value, in float */
@property (nonatomic,assign) float right;
/** @brief	Top coordinate value, in float. */
@property (nonatomic,assign) float top;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value for current rectangle.
 *
 * @param[in]	left		Left coordinate value for the rectangle, in floating point.
 * @param[in]	bottom		Bottom coordinate value for the rectangle, in floating point.
 * @param[in]	right		Right coordinate value for the rectangle, in floating point.
 * @param[in]	top			Top coordinate value for the rectangle, in floating point.
 * 
 * @return	None.
 */
-(void)set: (float)left bottom: (float)bottom right: (float)right top: (float)top;
/** 
 * @brief	Set left coordinate value , in floating point.
 * 
 * @param[in]	value	Value for left coordinate, in floating point.
 *
 * @return	None.
 */
-(void)setLeft: (float)value;
/** 
 * @brief	Get left coordinate value, in floating point.
 *
 * @return	Left coordinate value, in floating point.
 */
-(float)getLeft;
/** 
 * @brief	Set bottom coordinate value , in floating point.
 * 
 * @param[in]	value	Value for bottom coordinate, in floating point.
 *
 * @return	None.
 */
-(void)setBottom: (float)value;
/** 
 * @brief	Get bottom coordinate value, in floating point.
 *
 * @return	Bottom coordinate value, in floating point.
 */
-(float)getBottom;
/** 
 * @brief	Set right coordinate value , in floating point.
 * 
 * @param[in]	value	Value for right coordinate, in floating point.
 *
 * @return	None.
 */
-(void)setRight: (float)value;
/** 
 * @brief	Get right coordinate value, in floating point.
 *
 * @return	Right coordinate value, in floating point.
 */
-(float)getRight;
/** 
 * @brief	Set top coordinate value , in floating point.
 * 
 * @param[in]	value	Value for top coordinate, in floating point.
 *
 * @return	None.
 */
-(void)setTop: (float)value;
/** 
 * @brief	Get top coordinate value, in floating point.
 *
 * @return	Top coordinate value, in floating point.
 */
-(float)getTop;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent a rectangle, in integer.
 */
@interface FSRectI : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief	Left coordinate value, in integer. */
@property (nonatomic,assign) int left;
/** @brief	Bottom coordinate value, in integer. */
@property (nonatomic,assign) int bottom;
/** @brief	Right coordinate value, in integer. */
@property (nonatomic,assign) int right;
/** @brief	Top coordinate value, in integer. */
@property (nonatomic,assign) int top;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value for current rectangle.
 *
 * @param[in]	left		Left coordinate value for the rectangle, in integer.
 * @param[in]	bottom		Bottom coordinate value for the rectangle, in integer.
 * @param[in]	right		Right coordinate value for the rectangle, in integer.
 * @param[in]	top			Top coordinate value for the rectangle, in integer.
 * 
 * @return	None.
 */
-(void)set: (int)left top: (int)top right: (int)right bottom: (int)bottom;
/** 
 * @brief	Set left coordinate value, in integer.
 * 
 * @param[in]	value	Value for left coordinate, in integer.
 *
 * @return	None.
 */
-(void)setLeft: (int)value;
/** 
 * @brief	Get left coordinate value, in integer.
 *
 * @return	Left coordinate value, in integer.
 */
-(int)getLeft;
/** 
 * @brief	Set top coordinate value, in integer.
 * 
 * @param[in]	value	Value for top coordinate, in integer.
 *
 * @return	None.
 */
-(void)setTop: (int)value;
/** 
 * @brief	Get top coordinate value, in integer.
 *
 * @return	Top coordinate value, in integer.
 */
-(int)getTop;
/** 
 * @brief	Set right coordinate value, in integer.
 * 
 * @param[in]	value	Value for right coordinate, in integer.
 *
 * @return	None.
 */
-(void)setRight: (int)value;
/** 
 * @brief	Get right coordinate value, in integer.
 *
 * @return	Right coordinate value, in integer.
 */
-(int)getRight;
/** 
 * @brief	Set bottom coordinate value, in integer.
 * 
 * @param[in]	value	Value for bottom coordinate, in integer.
 *
 * @return	None.
 */
-(void)setBottom: (int)value;
/** 
 * @brief	Get bottom coordinate value, in integer.
 *
 * @return	Bottom coordinate value, in integer.
 */
-(int)getBottom;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent a matrix, used for transformation between two coordinate systems.
 *
 * @details	The transformation between two coordinate systems is represented by a 3-by-3
 *			transformation matrix written as follows:
 *			<pre>
 *			|a  b  0|
 *			|c  d  0|
 *			|e  f  1|
 *			</pre>
 *			Because a transformation matrix has only six elements that can be changed, it is
 *			usually specified in PDF as the six-element array [a b c d e f].
 */
@interface FSMatrix : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief	Coefficient a. */
@property (nonatomic,assign) float a;
/** @brief	Coefficient b. */
@property (nonatomic,assign) float b;
/** @brief	Coefficient c. */
@property (nonatomic,assign) float c;
/** @brief	Coefficient d. */
@property (nonatomic,assign) float d;
/** @brief	Coefficient e. */
@property (nonatomic,assign) float e;
/** @brief	Coefficient f. */
@property (nonatomic,assign) float f;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set the value for current matrix.
 *
 * @param[in]	a		Value for coefficient a.
 * @param[in]	b		Value for coefficient b.
 * @param[in]	c		Value for coefficient c.
 * @param[in]	d		Value for coefficient d.
 * @param[in]	e		Value for coefficient e.
 * @param[in]	f		Value for coefficient f.
 * 
 * @return	None.
 */
-(void)set: (float)a b: (float)b c: (float)c d: (float)d e: (float)e f: (float)f;
/**
 * @brief	Transform a float point.
 *
 * @param[in]	point	A float point to be transformed.
 *
 * @return	The transformed point.
 */
-(FSPointF*)transform: (FSPointF*)point;
/**
 * @brief	Transform a float rectangle.
 *
 * @param[in]	rect	A float rectangle to be transformed.
 *
 * @return	The transformed rectangle.
 */
-(FSRectF*)transformRect: (FSRectF*)rect;
/** 
 * @brief	Set coefficient a.
 * 
 * @param[in]	value	Value for coefficient a.
 *
 * @return	None.
 */
-(void)setA: (float)value;
/** 
 * @brief	Get coefficient a.
 *
 * @return	Coefficient a value.
 */
-(float)getA;
/** 
 * @brief	Set coefficient b.
 * 
 * @param[in]	value	Value for coefficient b.
 *
 * @return	None.
 */
-(void)setB: (float)value;
/** 
 * @brief	Get coefficient b.
 *
 * @return	Coefficient b value.
 */
-(float)getB;
/** 
 * @brief	Set coefficient c.
 * 
 * @param[in]	value	Value for coefficient c.
 *
 * @return	None.
 */
-(void)setC: (float)value;
/** 
 * @brief	Get coefficient c.
 *
 * @return	Coefficient c value.
 */
-(float)getC;
/** 
 * @brief	Set coefficient d.
 * 
 * @param[in]	value	Value for coefficient d.
 *
 * @return	None.
 */
-(void)setD: (float)value;
/** 
 * @brief	Get coefficient d
 *
 * @return	Coefficient d value.
 */
-(float)getD;
/** 
 * @brief	Set coefficient e.
 * 
 * @param[in]	value	Value for coefficient e.
 *
 * @return	None.
 */
-(void)setE: (float)value;
/** 
 * @brief	Get coefficient e
 *
 * @return	Coefficient e value.
 */
-(float)getE;
/** 
 * @brief	Set coefficient f.
 * 
 * @param[in]	value	Value for coefficient f.
 *
 * @return	None.
 */
-(void)setF: (float)value;
/** 
 * @brief	Get coefficient f
 *
 * @return	Coefficient f value.
 */
-(float)getF;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end
	
/** @brief	Class to represent date, time and timezone. */
@interface FSDateTime : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief	Year. It should be a four-digit number, such as 2014. */
@property (nonatomic,assign) unsigned short year;
/** @brief	Month. Valid range: from 1 to 12. */
@property (nonatomic,assign) unsigned short month;
/** @brief	Day of month. Valid range: from 1 to 31. */
@property (nonatomic,assign) unsigned short day;
/** @brief	Hour. Valid range: from 0 to 23. */
@property (nonatomic,assign) unsigned short hour;
/** @brief	Minute. Valid range: from 0 to 59. */
@property (nonatomic,assign) unsigned short minute;
/** @brief	Second. Valid range: from 0 to 60. 60 for leap second. */
@property (nonatomic,assign) unsigned short second;
/** @brief	Millisecond. Valid range: from 0 to 999. PDF standard does not support now, this can be omitted if it is not applicable. */
@property (nonatomic,assign) unsigned short millisecond;
/**
 * @brief	Hour of time zone. Valid range: from -12 to 12.
 *
 * @details	Positive value for the eastern time zone, and negative value for the western time zone.
 */
@property (nonatomic,assign) short UTHourOffset;
/** @brief	Minute of time zone. Valid range: from 0 to 59. */
@property (nonatomic,assign) unsigned short UTMinuteOffset;

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	year			Year. It should be a four-digit number, such as 2014.
 * @param[in]	month			Month. Valid range: from 1 to 12.
 * @param[in]	day				Day of month. Valid range: from 1 to 31.
 * @param[in]	hour			Hour. Valid range: from 0 to 23.
 * @param[in]	minute			Minute. Valid range: from 0 to 59.
 * @param[in]	second			Second. Valid range: from 0 to 60. 60 for leap second.
 * @param[in]	millisecond	Millisecond. Valid range: from 0 to 999. PDF standard does not support now, this can be omitted if it is not applicable.
 * @param[in]	UTHourOffset	Hour of time zone. Valid range: from -12 to 12.
 *								Positive value for the eastern time zone, and negative value for the western time zone. 
 * @param[in]	UTMinuteOffset	Minute of time zone. Valid range: from 0 to 59.
 * 
 * @return	None.
 */
-(void)set: (unsigned short)year month: (unsigned short)month day: (unsigned short)day hour: (unsigned short)hour minute: (unsigned short)minute second: (unsigned short)second millisecond: (unsigned short)millisecond UTHourOffset: (short)UTHourOffset UTMinuteOffset: (unsigned short)UTMinuteOffset;
/** 
 * @brief	Set value for year.
 * 
 * @param[in]	value	Value for year. It should be a four-digit number, such as 2014.
 *
 * @return	None.
 */
-(void)setYear: (unsigned short)value;
/** 
 * @brief	Get value for year.
 *
 * @return	Value for year. It would be a four-digit number, such as 2014.
 */
-(unsigned short)getYear;
/** 
 * @brief	Set value for month.
 * 
 * @param[in]	value	Value for month. Valid range: from 1 to 12.
 *
 * @return	None.
 */
-(void)setMonth: (unsigned short)value;
/** 
 * @brief	Get value for month.
 * 
 * @return	Value for month. Valid range: from 1 to 12.
 */
-(unsigned short)getMonth;
/** 
 * @brief	Set value for day of month.
 * 
 * @param[in]	value	Value for day of month. Valid range: from 1 to 31.
 *
 * @return	None.
 */
-(void)setDay: (unsigned short)value;
/** 
 * @brief	Get value for day of month.
 * 
 * @return	Value for day of month. Valid range: from 1 to 31.
 */
-(unsigned short)getDay;
/** 
 * @brief	Set value for hour.
 * 
 * @param[in]	value	Value for hour. Valid range: from 0 to 23.
 *
 * @return	None.
 */
-(void)setHour: (unsigned short)value;
/** 
 * @brief	Get value for hour.
 * 
 * @return	Value for hour. Valid range: from 0 to 23.
 */
-(unsigned short)getHour;
/** 
 * @brief	Set value for minute.
 * 
 * @param[in]	value	Value for minute. Valid range: from 0 to 59.
 *
 * @return	None.
 */
-(void)setMinute: (unsigned short)value;
/** 
 * @brief	Get value for minute.
 * 
 * @return	Value for minute. Valid range: from 0 to 59.
 */
-(unsigned short)getMinute;
/** 
 * @brief	Set value for second.
 * 
 * @param[in]	value	Value for second. Valid range: from 0 to 60. 60 for leap second.
 *
 * @return	None.
 */
-(void)setSecond: (unsigned short)value;
/** 
 * @brief	Get value for second.
 * 
 * @return	Value for second. Valid range: from 0 to 60. 60 for leap second.
 */
-(unsigned short)getSecond;
/** 
 * @brief	Set value for millisecond.
 * 
 * @param[in]	value	Value for millisecond. Valid range: from 0 to 999.
 *
 * @return	None.
 *
 * @note	Currently, PDF standard does not support millisecond, so user can omit this field if this is not applicable.
 */
-(void)setMillisecond: (unsigned short)value;
/** 
 * @brief	Get value for millisecond.
 * 
 * @return	Value for millisecond. Valid range: from 0 to 999.
 *			Currently, this function would always return 0 because PDF standard does not support it.
 */
-(unsigned short)getMillisecond;
/** 
 * @brief	Set the offset from Universal Coordinated Time (UTC) by hours.
 * 
 * @param[in]	value	Hours offset from UTC hour. Valid range: from -12 to 12. <br>
 *						Positive value for the eastern time zone, and negative value for the western time zone.
 *
 * @return	None.
 */
-(void)setUTHourOffset: (short)value;
/** 
 * @brief	Get the offset from Universal Coordinated Time (UTC) by hours.
 * 
 * @return	Hours offset from UTC hour. Valid range: from -12 to 12. <br>
 *			Positive value for the eastern time zone, and negative value for the western time zone.
 */
-(short)getUTHourOffset;
/** 
 * @brief	Set the offset from Universal Coordinated Time (UTC) by minutes.
 * 
 * @param[in]	value	Minutes offset from UTC minute. Valid range: from 0 to 59.
 *
 * @return	None.
 */
-(void)setUTMinuteOffset: (unsigned short)value;
/** 
 * @brief	Get the offset from Universal Coordinated Time (UTC) by minutes.
 * 
 * @return	Minutes offset from UTC minute. Valid range: 0 to 59.
 */
-(unsigned short)getUTMinuteOffset;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent a callback object to do file reading.
 * 
 * @details	All the functions in this class are used as callback functions 
 *			and should be implemented by user, to do file reading in a customized way.
 */
@interface FSFileReadCallback : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	A callback function used to get the total size of the file.
 *
 * @return	The file size, in bytes. 
 *			If any error occurs, implementation of this function should return 0.
 */
-(unsigned long long)getSize;
/**
 * @brief	A callback function used to read a data block from the file.
 *
 * @param[in]	offset			Byte offset from the beginning of the file.
 * @param[in]	size			The number of bytes for the block.
 *
 * @return	A data block from the file.
 *			If any error occurs, implementation of this function should return <b>nil</b>.
 */
-(NSData *)readBlock: (unsigned long long)offset size: (unsigned long long)size;

/** @brief Free the object. */
-(void)dealloc;

@end

 /**
 * @brief	Class to represent a callback object to do pause control in progressive process.
 * 
 * @details	All the functions in this class are used as callback functions and should be implemented by user.<br>
 * 			Usually, this is used for a process that may take a long time, such as rendering process, PDF page parsing process, 
 *			PDF searching process, and so on.
 */
@interface FSPauseCallback : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	A callback function used to decide whether current process needs to pause or not.
 *
 * @details	During a process, which may takes long time, Foxit PDF SDK will call this function several times to check whether application wants to pause the process or not.
 *			Usually, caller can use a timer to determine how long at most should wait before pause.
 *
 * @return	<b>YES</b> means the process needs to be paused, while <b>NO</b> means the process can continue to run without being paused.
 */
-(BOOL)needPauseNow;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Enumeration for action type.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ACTIONTYPE {
	/** @brief	Action type: unknown action. */
	e_actionTypeUnknown = 0,
	/** @brief	Action type: go-to action. */
	e_actionTypeGoto = 1,
	/** @brief	Action type: remote go-to action. */
	e_actionTypeGoToR = 2,
	/** @brief	Action type: embedded go-to action. */
	e_actionTypeGoToE = 3,
	/** @brief	Action type: launch action. */
	e_actionTypeLaunch = 4,
	/** @brief	Action type: thread action. */
	e_actionTypeThread = 5,
	/** @brief	Action type: uniform resource identifier (URI) action. */
	e_actionTypeURI = 6,
	/** @brief	Action type: sound action. */
	e_actionTypeSound = 7,
	/** @brief	Action type: movie action. */
	e_actionTypeMovie = 8,
	/** @brief	Action type: hide action. */
	e_actionTypeHide = 9,
	/** @brief	Action type: named action. */
	e_actionTypeNamed = 10,
	/** @brief	Action type: submit-form action. */
	e_actionTypeSubmitForm = 11,
	/** @brief	Action type: reset-form action. */
	e_actionTypeResetForm = 12,
	/** @brief	Action type: import-data action. */
	e_actionTypeImportData = 13,
	/** @brief	Action type: JavaScript action. */
	e_actionTypeJavaScript = 14,
	/** @brief	Action type: set-OCG-state action. */
	e_actionTypeSetOCGState = 15,
	/** @brief	Action type: rendition action. */
	e_actionTypeRendition = 16,
	/** @brief	Action type: transition action. */
	e_actionTypeTrans = 17,
	/** @brief	Action type: go-to-3D-view action. */
	e_actionTypeGoTo3DView = 18
};

/**
 * @brief	Class to represent destination information.
 *
 * @details	A destination defines a particular view of a PDF document, consisting of the following items:
 *			<ul>
 *			<li>The page of the document to be displayed.</li>
 *			<li>The location of the document window on that page.</li>
 *			<li>The magnification (zoom) factor to use when displaying the page.</li>
 *			</ul>
 *			Destinations may be associated with bookmarks, link annotations, or some types of actions.
 *			In each case, the destination specifies the view of the document to be presented when the bookmark 
 *			item or link annotation is opened or the action is performed.<br>
 *			This class offers functions to create destination objects for different zoom mode, and get destination data.
 *
 * @see FSBookmark
 * @see FSLink
 * @see FSGotoAction
 */
@interface FSDestination : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomXYZ}.
 *
 * @param[in]	page			The destination page.
 * @param[in]	left			Horizontal coordinate value of a position as page's left-top position.
 * @param[in]	top				Vertical coordinate value of a position as page's left-top position.
 * @param[in]	zoomFactor		Zoom factor value.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createXYZ: (FSPDFPage*)page left: (float)left top: (float)top zoomFactor: (float)zoomFactor;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitPage}.
 *
 * @param[in]	page	The destination page.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitPage: (FSPDFPage*)page;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitHorz}.
 *
 * @param[in]	page	The destination page.
 * @param[in]	top		Vertical coordinate of top edge.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitHorz: (FSPDFPage*)page top: (float)top;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitVert}.
 *
 * @param[in]	page	The destination page.
 * @param[in]	left	Horizontal coordinate of left edge.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitVert: (FSPDFPage*)page left: (float)left;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitRect}.
 *
 * @param[in]	page		The destination page.
 * @param[in]	left		The coordinate left of a rectangle.
 * @param[in]	bottom		The coordinate bottom of a rectangle.
 * @param[in]	right		The coordinate right of a rectangle.
 * @param[in]	top			The coordinate top of a rectangle.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitRect: (FSPDFPage*)page left: (float)left bottom: (float)bottom right: (float)right top: (float)top;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitBBox}.
 *
 * @param[in]	page		The destination page.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitBBox: (FSPDFPage*)page;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitBHorz}.
 *
 * @param[in]	page		The destination page.
 * @param[in]	top			Vertical coordinate of top edge
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitBHorz: (FSPDFPage*)page top: (float)top;
/**
 * @brief	Create a destination for zoom mode {@link FS_ZOOMMODE::e_zoomFitBVert}.
 *
 * @param[in]	page	The destination page.
 * @param[in]	left	Horizontal coordinate of left edge.
 *
 * @return	A new destination object.
 */
+(FSDestination*)createFitBVert: (FSPDFPage*)page left: (float)left;
/** 
 * @brief	Get the index of the destination page.
 * 
 * @return	The page index, starting from 0.
 *			If there is any error, this function will return -1.
 */
-(int)getPageIndex;
/**
 * @brief	Get the zoom mode
 *
 * @return	Zoom mode value. Please refer to {@link FS_ZOOMMODE::e_zoomXYZ FS_ZOOMMODE::e_zoomXXX} values and it would be one of them.
 *			If there is any error, this function will return 0.
 */
-(enum FS_ZOOMMODE)getZoomMode;
/**
 * @brief	Get left position value.
 *
 * @details	This is only useful when zoom mode is {@link FS_ZOOMMODE::e_zoomXYZ}, {@link FS_ZOOMMODE::e_zoomFitVert}, {@link FS_ZOOMMODE::e_zoomFitRect} or {@link FS_ZOOMMODE::e_zoomFitBVert}.
 *			For other zoom mode, this function will return 0.0f.
 *
 * @return	The left position value.
 */
-(float)getLeft;
/**
 * @brief	Get top position value.
 *
 * @details	This is only useful when zoom mode is {@link FS_ZOOMMODE::e_zoomXYZ}, {@link FS_ZOOMMODE::e_zoomFitHorz}, {@link FS_ZOOMMODE::e_zoomFitBHorz} or {@link FS_ZOOMMODE::e_zoomFitRect}.
 *			For other zoom mode, this function will return 0.0f.
 *
 * @return	The top position value.
 */
-(float)getTop;
/**
 * @brief	Get right position value.
 *
 * @details	This is only useful when zoom mode is {@link FS_ZOOMMODE::e_zoomFitRect}.
 *			For other zoom mode, this function will return 0.0f.
 *
 * @return	The right position value.
 */
-(float)getRight;
/**
 * @brief	Get bottom position value.
 *
 * @details	This is only useful when zoom mode is {@link FS_ZOOMMODE::e_zoomFitRect}.
 *			For other zoom mode, this function will return 0.0f.
 *
 * @return	The bottom position value.
 */
-(float)getBottom;
/**
 * @brief	Get zoom factor.
 *
 * @details	This is only useful when zoom mode is {@link FS_ZOOMMODE::e_zoomXYZ}.
 *			For other zoom mode, this function will return 0.0f.
 *
 * @return	The zoom factor.
 */
-(float)getZoomFactor;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to access a PDF action.
 *
 * @details	PDF supports following standard action types:<br>
 *			"Go-To Action", "Remote Go-To Action", "Embedded Go-To Action", "Launch Action", "Thread Action", 
 *			"URI Action", "Sound Action", "Movie Action", "Hide Action", "Named Action", "Submit-Form Action", 
 *			"Reset-Form Action", "Import-Data Action", "JavaScript Action", "Set-OCG-State Action", "Rendition Action", 
 *			"Transition Action", "Go-To-3D-View Action".<br>
 *			A PDF action may have sub-actions. When this action is triggered, its sub-actions should also be triggered in turn.<br>
 *			Class ::FSAction is a base class for all kinds of PDF actions. 
 *			For concrete action types, please refer to derived classes. 
 *			Currently, Foxit PDF SDK supports to get a ::FSAction object from a link annotation, 
 *			by function {@link FSLink::getAction}.
 *
 * @see FSLink
 */
@interface FSAction : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Get action type.
 * 
 * @return	Action type. Please refer to {@link FS_ACTIONTYPE::e_actionTypeGoto FS_ACTIONTYPE::e_actionTypeXXX} values and it would be one of them.
 */
-(enum FS_ACTIONTYPE)getType;
/**
 * @brief	Get the count of sub-actions.
 *
 * @return	The count of sub-actions.
 */
-(int)getSubActionCount;
/** 
 * @brief	Get the sub-actions by index.
 * 
 * @param[in]	index	Index of sub-action to be retrieved. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSAction::getSubActionCount}.
 *
 * @return	A action instance for sub-action.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSAction*)getSubAction: (int)index;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to access a go-to action.
 *
 * @details	Go-to action is an action that changes the view to a specified destination (page, location, and magnification factor).<br>
 *			Class ::FSGotoAction is derived from ::FSAction and offers functions to access go-to action data.
 *
 * @see FSAction
 */
@interface FSGotoAction : FSAction
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the destination which the action will jump to.
 *
 * @return	A destination instance object. 
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSDestination*)getDestination;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to access a uniform resource identifier (URI) action.
 *
 * @details	URI action is an action that causes a URI to be resolved.
 *			Class ::FSURIAction is derived from ::FSAction and offers functions to access URI action data.
 *
 * @see FSAction
 */
@interface FSURIAction : FSAction
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the URI string.
 *
 * @return	URI string.
 */
-(NSString *)getURI;
/** 
 * @brief	Check whether to track the mouse position when the URI is resolved.
 *
 * @return	<b>YES</b> means application should track the mouse position, 
 *			while <b>NO</b> means no need to track the mouse position.
 */
-(BOOL)isTrackPosition;

/** @brief Free the object. */
-(void)dealloc;

@end
	
/** 
 * @brief	Enumeration for PDF annotation type.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ANNOTTYPE {
	/** @brief	Annotation type: unknown.*/
	 e_annotUnknownType= 0,
	/** @brief	Annotation type: note annotation, which is just "Text" annotation defined in <PDF reference 1.7>.*/
	 e_annotNote		= 1,
	/** @brief	Annotation type: link annotation.*/
	 e_annotLink		= 2,
	/** @brief	Annotation type: free text annotation.*/
	 e_annotFreeText	= 3,
	/** @brief	Annotation type: line annotation.*/
	 e_annotLine		= 4,
	/** @brief	Annotation type: square annotation.*/
	 e_annotSquare	= 5,
	/** @brief	Annotation type: circle annotation.*/
	 e_annotCircle	= 6,
	/** @brief	Annotation type: polygon annotation.*/
	 e_annotPolygon	= 7,
	/** @brief	Annotation type: polyline annotation.*/
	 e_annotPolyLine	= 8,
	/** @brief	Annotation type: highlight annotation.*/
	 e_annotHighlight= 9,
	/** @brief	Annotation type: underline annotation.*/
	 e_annotUnderline= 10,
	/** @brief	Annotation type: squiggly annotation.*/
	 e_annotSquiggly	= 11,
	/** @brief	Annotation type: strikeout annotation.*/
	 e_annotStrikeOut= 12,
	/** @brief	Annotation type: stamp annotation.*/
	 e_annotStamp	= 13,
	/** @brief	Annotation type: caret annotation.*/
	 e_annotCaret	= 14,
	/** @brief	Annotation type: ink annotation.*/
	 e_annotInk		= 15,
	/** @brief	Annotation type: pressure sensitive ink annotation.*/
	 e_annotPSInk	= 16,
	/** @brief	Annotation type: file attachment annotation.*/
	 e_annotFileAttachment		= 17,
	/** @brief	Annotation type: sound annotation.*/
	 e_annotSound	= 18,
	/** @brief	Annotation type: movie annotation.*/
	 e_annotMovie	= 19,
	/** @brief	Annotation type: widget annotation.*/
	 e_annotWidget	= 20,
	/** @brief	Annotation type: screen annotation.*/
	 e_annotScreen	= 21,
	/** @brief	Annotation type: printer's mark annotation.*/
	 e_annotPrinterMark= 22,
	/** @brief	Annotation type: trap network annotation.*/
	 e_annotTrapNet	= 23,
	/** @brief	Annotation type: watermark annotation.*/
	 e_annotWatermark= 24,
	/** @brief	Annotation type: 3D annotation.*/
	 e_annot3D		= 25,
	/** @brief	Annotation type: pop-up annotation.*/
	 e_annotPopup	= 26
};

/** 
 * @brief	Enumeration for PDF annotation flags.
 * 
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_ANNOTFLAGS {
	/** @brief	Annotation flag: invisible */
	e_annotFlagInvisible = 0x0001,
	/** @brief	Annotation flag: hidden */
	e_annotFlagHidden = 0x0002,
	/** @brief	Annotation flag: print */
	e_annotFlagPrint = 0x0004,
	/** @brief	Annotation flag: no zoom */
	e_annotFlagNoZoom = 0x0008,
	/** @brief	Annotation flag: no rotate */
	e_annotFlagNoRotate = 0x0010,
	/** @brief	Annotation flag: no view */
	e_annotFlagNoView = 0x0020,
	/** @brief	Annotation flag: read only */
	e_annotFlagReadOnly = 0x0040,
	/** @brief	Annotation flag: locked */
	e_annotFlagLocked = 0x0080,
	/** @brief	Annotation flag: toggle no view */
	e_annotFlagToggleNoView = 0x0100,
	/** @brief	Annotation flag: locked contents */
	e_annotFlagLockedContents = 0x0200
};

/** 
 * @brief	Enumeration for PDF annotation border style.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_BORDERSTYLE {
	/** @brief	Border style: Solid */ 
	 e_borderStyleSolid		= 0,
	/** 
	 * @brief	Border style: Dashed. 
	 *
	 * @details	This is only useful for link, free text, line, square, circle, polygon, and polyline annotation. 
	 *			If this is set to other type annotation, Foxit PDF SDK will change to set border style as {@link FS_BORDERSTYLE::e_borderStyleSolid} by default internally.
	 */ 
	 e_borderStyleDashed	= 1,
	/** 
	 * @brief	Border style: Underline.
	 *
	 * @details	This is only useful for link annotation. 
	 *			If this is set to other type annotation, Foxit PDF SDK will change to set border style as {@link FS_BORDERSTYLE::e_borderStyleSolid} by default internally.
	 */ 
	 e_borderStyleUnderLine	= 2,
	/** 
	 * @brief	Border style: Beveled. 
	 *
	 * @details	Currently, Foxit PDF SDK does not support the annotation appearance of this border style.
	 *			If this is set to any annotation, Foxit PDF SDK will change to set border style as {@link FS_BORDERSTYLE::e_borderStyleSolid} by default internally.
	 */ 
	 e_borderStyleBeveled	= 3,
	/** 
	 * @brief	Border style: Inset.
	 *
	 * @details	Currently, Foxit PDF SDK does not support the annotation appearance of this border style.
	 *			If this is set to any annotation, Foxit PDF SDK will change to set border style as {@link FS_BORDERSTYLE::e_borderStyleSolid} by default internally.
	 */ 
	 e_borderStyleInset		= 4,
	/** 
	 * @brief	Border style: Cloudy. 
	 *
	 * @details	This is only useful for free text, square, circle, and polygon annotations. 
	 *			If this is set to other type annotation, Foxit PDF SDK will change to set border style as {@link FS_BORDERSTYLE::e_borderStyleSolid} by default internally.
	 */ 
	 e_borderStyleCloudy	= 5
};

/** 
 * @brief	Enumeration for PDF annotation highlighting mode.
 * 
 * @details	Values of this enumeration should be used alone.
 */
enum FS_HIGHLIGHTINGMODE {
	/** @brief	Highlighting mode: None. */
	 e_highlightingModeNone			= 0 ,
	/** @brief	Highlighting mode: Invert */
	 e_highlightingModeInvert		= 1 ,
	/** @brief	Highlighting mode: Outline */
	 e_highlightingModeOutline		= 2 ,
	/** @brief	Highlighting mode: Push */
	 e_highlightingModePush			= 3 ,
	/** @brief	Highlighting mode: Toggle. This is only useful for widget annotation. */
	 e_highlightingModeToggle		= 4
};

/**
 * @brief	Class to access a PDF annotation.
 *
 * @details	An annotation associates an object such as a note, sound, or movie with a location 
 *			on a page of a PDF document, or provides a way to interact with the user by 
 *			means of the mouse and keyboard. PDF includes a wide variety of standard annotation types.<br>
 *			This is a base class for all kinds of PDF annotations. It offers the base functions 
 *			to access annotation's common properties, to move or reset appearance stream of an annotation. 
 *			For concrete annotation types, please refer to derived classes. <br>
 *			To get the count of annotations or get/add/remove an annotation, please refer to class ::FSPDFPage.
 *
 * @note	Currently, The supported annotation types are note, highlight, underline, strikeout, squiggly, link annotations:
 *			<ul>
 *			<li>1. All the "set" functions in class FSAnnot.</li>
 *			<li>2. Functions {@link FSAnnot::move:}, and {@link FSAnnot::resetAppearanceStream}.</li>
 *			</ul>
 *
 * @see FSPDFPage
 */
@interface FSAnnot : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the related PDF page.
 * 
 * @return	The related PDF page instance.
 *			Do not call function {@link FSPDFDoc::closePage:} for the returned page instance.
 */
-(FSPDFPage*)getPage;
/**
 * @brief	Check if current annotation is a markup annotation.
 *
 * @return	<b>YES</b> means current annotation is a markup annotation, while <b>NO</b> means current annotation is not a markup annotation.
 */
-(BOOL)isMarkup;
/**
 * @brief	Get actual annotation type of current annotation.
 *
 * @return	Annotation type.
 *			Please refer to {@link FS_ANNOTTYPE::e_annotNote FS_ANNOTTYPE::e_annotXXX} values and it would be one of these values.
 */
-(enum FS_ANNOTTYPE)getType;
/**
 * @brief	Get the index of current annotation, in the page which current annotation belongs to.
 *
 * @return	The index value, starting from 0. 
 *			If there is any error, -1 would be returned.
 */
-(int)getIndex;
/**
 * @brief	Get content.
 *
 * @return	Content string.
 */
-(NSString *)getContent;
/**
 * @brief	Set content.
 *
 * @param[in]	content		New content string to be set.
 *
 * @return	None.
 */
-(void)setContent: (NSString *)content;
/**
 * @brief	Get last modification date time.
 *
 * @return	A date time instance that receives the last modified date time.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSDateTime*)getModifiedDateTime;
/**
 * @brief	Set last modification date time.
 *
 * @param[in]	dataTime		The data time to be set. It should contain valid date time data.
 *
 * @return	None.
 */
-(void)setModifiedDateTime: (FSDateTime*)dataTime;
/**
 * @brief	Get annotation flags.
 *
 * @return	The annotation flags. 
 *			Please refer to {@link FS_ANNOTFLAGS::e_annotFlagInvisible FS_ANNOTFLAGS::e_annotFlagXXX} values and it would be one or a combination of them.
 *			0 means no annotation flag.
 */
-(unsigned int)getFlags;
/**
 * @brief	Set annotation flags.
 *
 * @param[in]	flags	The annotation flags. 
 *						It could be 0, or one or a combination of {@link FS_ANNOTFLAGS::e_annotFlagInvisible FS_ANNOTFLAGS::e_annotFlagXXX} values.
 *
 * @return	None.
 */
-(void)setFlags: (unsigned int)flags;
/**
 * @brief	Get unique ID.
 *
 * @return	Unique ID string.
 */
-(NSString *)getUniqueID;
/**
 * @brief	Set unique ID.
 *
 * @param[in]	uniqueID		New unique ID string to be set.
 *
 * @return	None.
 */
-(void)setUniqueID: (NSString *)uniqueID;
/** 
 * @brief	Get rectangle, in PDF coordinate system.
 *
 * @return	Annotation's rectangle, in PDF coordinate system.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSRectF*)getRect;
/** 
 * @brief	Move current annotation to a new position, specified by a new rectangle in PDF coordinate system.
 *
 * @param[in]	rect	New rectangle to specify the new position where current annotation is to be moved to.
 *						It should be valid in PDF coordinate system.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)move: (FSRectF*)rect;
/** 
 * @brief	Get border information.
 *
 * @details	For an annotation which does not have border information, the default border information will be returned:<br>
 *			width of {@link FSBorderInfo} is 1, style of {@link FSBorderInfo} is {@link FS_BORDERSTYLE::e_borderStyleSolid}, 
 *			intensity of {@link FSBorderInfo} is -1, dashPhase of {@link FSBorderInfo} is 0, 
 *			dashes array of {@link FSBorderInfo} is <b>nil</b>.
 *
 * @return	A ::FSBorderInfo object that received the border information.
 *			If not find any border information, the default border information would be returned as described in "Details" part.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSBorderInfo*)getBorderInfo;
/** 
 * @brief	Set border information.
 *
 * @param[in]	border		New border information to be set. Values of border information should be valid.<br>
 *							If any value of parameter <i>border</i> is invalid, this function will fail to set new border information to current annotation.
 *
 * @return	None.
 */
-(void)setBorderInfo: (FSBorderInfo*)border;
/**
 * @brief	Get border color.
 *
 * @return	The border color. Format: 0xAARRGGBB. 
 *			If succeed to get the color, alpha value will be ignored and will always be 0xFF by default.
 *			If no border color can be found or any error occurs, 0x00000000 will be returned.
 */
-(unsigned int)getBorderColor;
/**
 * @brief	Set border color.
 * 
 * @param[in]	color		New border color to be set. Format: 0xAARRGGBB.
 *							Alpha value is ignored and will always be treated as 0xFF internally.
 *
 * @return	None.
 */
-(void)setBorderColor: (unsigned int)color;
/** 
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/** 
 * @brief	Get annotation rectangle in device coordinate system.
 *
 * @details	This is a useful function to get the device rectangle of an annotation, but not support pop-up annotation.<br>
 *			For the rectangle conversion, the result rectangle is always "normalized", 
 *			which is based on device coordinate system: left is always smaller than right, and top is always smaller than bottom.
 *
 * @param[in]	isTransformIcon	A boolean value which indicates that whether to transform (like rotate or scale) the icon with page:
 *								<b>YES</b> means to transform icon's rectangle with page, 
 *								while <b>NO</b> means not transform icon's rectangle with page.<br>
 *								This parameter only affects on "Text" and "FileAttachment" annotations, because they are shown as icon.
 * @param[in]	matrix			A matrix used to transform from PDF coordinate system to device coordinate system. 
 *								Usually, this is returned by function {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:} and also used for rendering.
 *
 * @return	A rectangle in device coordinate system.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSRectI*)getDeviceRect: (BOOL)isTransformIcon matrix: (FSMatrix*)matrix;
/** 
 * @brief	Get annotation's dictionary.
 *
 * @return	Annotation's dictionary.
 */
-(FSPDFDictionary*)getDict;

/** @brief Free the object. */
-(void)dealloc;

@end
	
/** 
 * @brief	Class to represent annotation border information.
 *
 * @details	This class offers functions to access PDF annotation border information, 
 *			such as border width, border style and so on. 
 *			This class is used for functions {@link FSAnnot::getBorderInfo} and {@link FSAnnot::setBorderInfo:}.
 * 
 * @see FSAnnot
 */
@interface FSBorderInfo : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	width		Border width, in points. This should be a non-negative value. 
 *							If this value is 0, no border is drawn.
 * @param[in]	style		Border style. Please refer to {@link FS_BORDERSTYLE::e_borderStyleSolid FS_BORDERSTYLE::e_borderStyleXXX} values and it should be one of these values.
 * @param[in]	intensity	Intensity of the cloudy effect. Only useful when parameter <i>style</i> is {@link FS_BORDERSTYLE::e_borderStyleCloudy}.<br>
 *							Valid value range: 0 to 2. -1 mean no cloudy border effect.
 * @param[in]	dashPhase	Dash phase. Only useful when parameter <i>style</i> is {@link FS_BORDERSTYLE::e_borderStyleDashed}.
 * @param[in]	dashes		Dashes array, with float values. Only useful when parameter <i>style</i> is {@link FS_BORDERSTYLE::e_borderStyleDashed}.<br>
 *							Only the first 16 elements will be used and all the useful elements in this array should be a non-negative float value.<br>
 *							<b>nil</b> means no dash pattern array is needed.
 * 
 * @return	None.
 */
-(void)set: (float)width style: (enum FS_BORDERSTYLE)style intensity: (float)intensity dashPhase: (float)dashPhase dashes: (NSArray *)dashes;
/**
 * @brief	Set border width, in points.
 *
 * @param[in]	value	Border width. This value should not be negative. 
 *						If this value is 0, no border will be drawn. 
 * @return None.
 */
-(void)setWidth: (float)value;
/**
 * @brief	Get border width, in points.
 *
 * @return	Border width. It would be non-negative.
 *			0 means no border will be drawn. 
 */
-(float)getWidth;
/** 
 * @brief	Set border style. 
 *
 * @param[in]	value	Border style.
 *						Please refer to enumeration {@link FS_BORDERSTYLE::e_borderStyleSolid FS_BORDERSTYLE::e_borderStyleXXX} and this should be one of its values.
 *						Please also check comment of these values for more details.
 *
 * @return	None.
 */
-(void)setStyle: (enum FS_BORDERSTYLE)value;
/** 
 * @brief	Get border style. 
 *
 * @return	Border style.
 *			Please refer to enumeration {@link FS_BORDERSTYLE::e_borderStyleSolid FS_BORDERSTYLE::e_borderStyleXXX} and this should be one of its values.
 */
-(enum FS_BORDERSTYLE)getStyle;
/** 
 * @brief	Set intensity of the cloudy effect. 
 *
 * @details	Intensity of the cloudy effect is only useful to free text, square, circle, polygon, and polyline annotations 
 *			when FSBorderInfo::Style is {@link FS_BORDERSTYLE::e_borderStyleCloudy}.
 *
 * @param[in]	value	Intensity of the cloudy effect. Valid value range: 0 to 2. 
 *						-1 mean no cloudy border effect.<br>
 *
 * @return	None.
 */
-(void)setCloudIntensity: (float)value;
/** 
 * @brief	Get intensity of the cloudy effect. 
 *
 * @details	Intensity of the cloudy effect is only useful to free text, square, circle, polygon, and polyline annotations 
 *			when FSBorderInfo::Style is {@link FS_BORDERSTYLE::e_borderStyleCloudy}.
 *
 * @return	Intensity of the cloudy effect. Valid value range: 0 to 2. 
 *			-1 mean no cloudy border effect.<br>
 */
-(float)getCloudIntensity;
/** 
 * @brief	Set dash phase. 
 *
 * @details	Dash phase is only useful when FSBorderInfo::Style is {@link FS_BORDERSTYLE::e_borderStyleDashed}.
 *
 * @param[in]	value	New dash phase. 
 *
 * @return	None.
 */
-(void)setDashPhase: (float)value;
/** 
 * @brief	Get dash phase. 
 *
 * @details	Dash phase is only useful when FSBorderInfo::Style is {@link FS_BORDERSTYLE::e_borderStyleDashed}.
 *
 * @return	Dash phase. 
 */
-(float)getDashPhase;
/** 
 * @brief	Set dash pattern array. 
 *
 * @details	Dashes array is only useful when FSBorderInfo::Style is {@link FS_BORDERSTYLE::e_borderStyleDashed}.
 *
 * @param[in]	value	New dash pattern array, with float values.
 *						Only the first 16 elements will be used and all the useful elements in this array should be non-negative float value.<br>
 *						<b>nil</b> means no dash pattern array is needed.
 * @return	None.
 */
-(void)setDashes: (NSArray *)value;
/** 
 * @brief	Get dash pattern array. 
 *
 * @details	Dashes array is only useful when FSBorderInfo::Style is {@link FS_BORDERSTYLE::e_borderStyleDashed}.
 *
 * @return	Dashes array, with at most 16 valid float values.
 *			<b>nil</b> means no dash pattern array.
 */
-(NSArray *)getDashes;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent a quadrilateral, in PDF coordinate system.
 *
 * @details	The order of points in a quadrilateral should be:
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *			This class offers functions to access points values of a quadrilateral.
 */
@interface FSQuadPoints : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}

/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	first		First point of the quadrilateral, in PDF coordinate system.
 * @param[in]	second		Second point of the quadrilateral, in PDF coordinate system.
 * @param[in]	third		Third point of the quadrilateral, in PDF coordinate system.
 * @param[in]	fourth		Fourth point of the quadrilateral, in PDF coordinate system.
 * 
 * @return	None.
 */
-(void)set: (FSPointF*)first second: (FSPointF*)second third: (FSPointF*)third fourth: (FSPointF*)fourth;
/** 
 * @brief	Set first point of quadrilateral, in PDF coordinate system.
 *
 * @param[in]	value	First point to be set.
 *
 * @return	None.
 */
-(void)setFirst: (FSPointF*)value;
/** 
 * @brief	Get first point of quadrilateral, in PDF coordinate system.
 *
 * @return	First point value.
 */
-(FSPointF*)getFirst;
/** 
 * @brief	Set second point of quadrilateral, in PDF coordinate system. 
 *
 * @param[in]	value	Second point to be set.
 *
 * @return	None.
 */
-(void)setSecond: (FSPointF*)value;
/** 
 * @brief	Get second point of quadrilateral, in PDF coordinate system. 
 *
 * @return	Second point value.
 */
-(FSPointF*)getSecond;
/** 
 * @brief	Set third point of quadrilateral, in PDF coordinate system. 
 *
 * @param[in]	value	Third point to be set.
 *
 * @return	None.
 */
-(void)setThird: (FSPointF*)value;
/** 
 * @brief	Get third point of quadrilateral, in PDF coordinate system. 
 *
 * @return	Third point value.
 */
-(FSPointF*)getThird;
/** 
 * @brief	Set fourth point of quadrilateral, in PDF coordinate system. 
 *
 * @param[in]	value	Fourth point to be set.
 *
 * @return	None.
 */
-(void)setFourth: (FSPointF*)value;
/** 
 * @brief	Get fourth point of quadrilateral, in PDF coordinate system. 
 *
 * @return	Fourth point value.
 */
-(FSPointF*)getFourth;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end

/**
 * @brief	Class to represent shading color.
 *
 * @details	This class represents colors used for Type 2 (Axial) Shadings. 
 *			It offers functions to access the 2 colors used for Type 2 (Axial) Shadings. 
 */
@interface FSShadingColor : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	firstColor		First color used for shading. Format: 0xAARRGGBB.
 * @param[in]	secondColor		Second color used for shading. Format: 0xAARRGGBB.
 * 
 * @return	None.
 */
-(void)set: (unsigned int)firstColor secondColor: (unsigned int)secondColor;
/** 
 * @brief	Set first color used for shading. 
 *
 * @param[in]	value	First color to be set. Format: 0xAARRGGBB. 
 *
 * @return	None.
 */
-(void)setFirstColor: (unsigned int)value;
/** 
 * @brief	Get first color used for shading. 
 *
 * @return	First color. Format: 0xAARRGGBB. 
 */
-(unsigned int)getFirstColor;
/** 
 * @brief	Set second color used for shading. 
 *
 * @param[in]	value	Second color to be set. Format: 0xAARRGGBB. 
 *
 * @return	None.
 */
-(void)setSecondColor: (unsigned int)value;
/** 
 * @brief	Get second color used for shading. 
 *
 * @return	Second color. Format: 0xAARRGGBB. 
 */
-(unsigned int)getSecondColor;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to represent a callback object as customized annotation icon provider.
 * 
 * @details	All the functions int this class are used as callback functions and should be implemented by user.
 *			Icon provider can only be used for note, file attachment, stamp annotations.
 */
@interface FSAnnotIconProviderCallback : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	A callback function used to get provider ID. 
 *
 * @return	The provider ID string.
 */
-(NSString *)getProviderID;
/**
 * @brief	A callback function used to get provider version. 
 *
 * @return	Version string.
 */
-(NSString *)getProviderVersion;
/** 
 * @brief	A callback function used to check if current icon provider supports icon for a specified type. 
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotFileAttachment} and {@link FS_ANNOTTYPE::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECKMARK FS_ANNOT_ICONNAME_XXX}.
 *
 * @return	<b>YES</b> means current icon provider supports the specific icon, 
 *			while <b>NO</b> means not support.
 */
-(BOOL)hasIcon: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName;
/** 
 * @brief	A callback function used to check if current icon provider supports to change color for a specified type. 
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotFileAttachment} and {@link FS_ANNOTTYPE::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECKMARK FS_ANNOT_ICONNAME_XXX}.
 *
 * @return	<b>YES</b> means current icon provider supports to change color for a specific icon type, 
 *			while <b>NO</b> means not support.
 */
-(BOOL)canChangeColor: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName;
/** 
 * @brief	A callback function used to get the icon as PDF page contents for a specified type. 
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotFileAttachment} and {@link FS_ANNOTTYPE::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECKMARK FS_ANNOT_ICONNAME_XXX}.
 * @param[in]	color		The annotation icon color. Format: 0xAARRGGBB. 
 *
 * @return	A page instance, whose content would be used as the icon.
 */
-(FSPDFPage*)getIcon: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName color: (unsigned int)color;
/** 
 * @brief	A callback function used to get the shading colors if current icon provider supports for a specified type.
 *			Currently, only support Type-2 shading settings with two color values.
 *
 * @param[in]	annotType		The annotation type.
 *								It should be one of {@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotFileAttachment} and {@link FS_ANNOTTYPE::e_annotStamp}.
 * @param[in]	iconName		The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECKMARK FS_ANNOT_ICONNAME_XXX}.
 * @param[in]	refColor		Referenced color. Format: 0xAARRGGBB and alpha component is ignored.
 * @param[in]	shadingIndex	Index color of shading, starting from 0. If shading colors are more than one, this function will be called multiple times.
 *
 * @return	The two shading color value.
 *			If there is any error, implementation of this function should return <b>nil</b>.
 */
-(FSShadingColor*)getShadingColor: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName refColor: (unsigned int)refColor shadingIndex: (int)shadingIndex;
/** 
 * @brief	A callback function used to get the width for display of a specified icon, in device size(pixel normally).
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotFileAttachment} and {@link FS_ANNOTTYPE::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECKMARK FS_ANNOT_ICONNAME_XXX}.
 *
 * @return	The width for display.
 */
-(NSNumber*)getDisplayWidth: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName;
/** 
 * @brief	A callback function used to get the height for display of a specific icon, in device size(pixel normally).
 *
 * @param[in]	annotType	The annotation type.
 *							It should be one of {@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotFileAttachment} and {@link FS_ANNOTTYPE::e_annotStamp}.
 * @param[in]	iconName	The annotation icon name. Please refer to macro definitions {@link ::FS_ANNOT_ICONNAME_TEXT_CHECKMARK FS_ANNOT_ICONNAME_XXX}.
 *
 * @return	The height for display.
 */
-(NSNumber*)getDisplayHeight: (enum FS_ANNOTTYPE)annotType iconName: (NSString *)iconName;

/** @brief Free the object. */
-(void)dealloc;

@end


/** 
 * @brief	Class to access a markup annotation.
 *
 * @details	Markup annotations are used mainly to mark up PDF documents. These annotations have
 *			text that appears as part of the annotation and may be displayed in other ways by 
 *			a viewer application, such as in a comments pane.<br>
 *			Class ::FSMarkup is a base class for all PDF markup annotations. It offers the basic functions
 *			to access markup annotation's common properties. 
 *			For concrete markup annotation types, please refer to derived classes. <br>
 *			Function {@link FSAnnot::isMarkup} can be used to judge if an annotation is a markup annotation.
 *
 * @note	Currently, following kind of functions only support note, highlight, underline, strikeout, squiggly annotations:
 *			<ul>
 *			<li>1. All the "set" functions in class FSMarkup.</li>
 *			<li>2. Function {@link FSMarkup::resetAppearanceStream}.</li>
 *			</ul>
 *
 * @see FSAnnot
 */
@interface FSMarkup : FSAnnot
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get title.
 *
 * @return	Title string.
 */
-(NSString *)getTitle;
/** 
 * @brief	Set title string.
 *
 * @param[in]	title		New title string to be set.
 *
 * @return	None.
 */
-(void)setTitle: (NSString *)title;
/**
 * @brief	Get subject.
 *
 * @return	Subject string.
 */
-(NSString *)getSubject;
/**
 * @brief	Set subject.
 *
 * @param[in]	subject		New subject string to be set.
 *
 * @return	None.
 */
-(void)setSubject: (NSString *)subject;
/**
 * @brief	Get opacity.
 *
 * @return	The opacity value. Valid range: from 0.0 to 1.0.
 */
-(float)getOpacity;
/**
 * @brief	Set opacity.
 *
 * @param[in]	opacity		The new opacity value. Valid range: 0.0 to 1.0 .
 *
 * @return	None.
 */
-(void)setOpacity: (float)opacity;
/**
 * @brief	Get intent.
 *
 * @details	Following annotation types have predefined intent name:<br>
 *			<ul>
 *			<li>Free text annotation's predefined intent name: "FreeTextCallout", "FreeTextTypewriter".</li>
 *			<li>Line annotation's predefined intent name: "LineArrow", "LineDimension".</li>
 *			<li>Polygon's predefined intent name: "PolygonCloud", "PolygonDimension".</li>
 *			<li>Polyline annotation's predefined intent name: "PolyLineDimension".</li>
 *			</ul>
 *
 * @return	The intent name string.
 */
-(NSString *)getIntent;
/**
 * @brief	Set intent.
 *
 * @param[in]	intent		New intent name string to be set. <br>
 *							Some annotation type have predefined intent name, please refer to "Details" part of {@link FSMarkup::getIntent} for more details.
 *
 * @return	None.
 */
-(void)setIntent: (NSString *)intent;
/**
 * @brief	Get creation date time.
 *
 * @return	A date time instance.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSDateTime*)getCreationDateTime;
/**
 * @brief	Set creation date time.
 *
 * @param[in]	dateTime	The new date time to be set.
 *
 * @return	None.
 */
-(void)setCreationDateTime: (FSDateTime*)dateTime;
/**
 * @brief	Count all replies.
 *
 * @return	The count of replies.
 */
-(int)getReplyCount;
/**
 * @brief	Get a reply by index.
 *
 * @param[in]	index	The index for a specified reply. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSMarkup::getReplyCount}.
 *
 * @return	A note annotation instance which is used as a reply.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSNote*)getReply: (int)index;
/**
 * @brief	Add a reply to the end of reply list.
 *
 * @return	A new note annotation instance which is used as the new reply.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSNote*)addReply;
/**
 * @brief	Remove a reply by index.
 *
 * @details	If specific reply has its own replies, these sub replies will be removed at the same time.
 *
 * @param[in]	index	The index for a specified reply to be removed. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSMarkup::getReplyCount}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeReply: (int)index;
/**
 * @brief	Remove all replies.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeAllReplies;

/** @brief Free the object. */
-(void)dealloc;

@end


/** 
 * @brief	Class to access a note annotation.
 * 
 * @details	A note annotation (known as "text" annotation in <PDF reference 1.7> represents a "sticky note" 
 *			attached to a point in the PDF document. When closed, the annotation appears as an icon; 
 *			when open, it displays a pop-up window containing the text of the note in a font and size 
 *			chosen by the viewer application. <br>
 *			A note annotation is also used as a reply to a markup annotation.
 *			When as a reply, the note annotation should not be shown alone 
 *			but together with other replies in the form of threaded comments.
 *			Class ::FSNote is derived from ::FSMarkup 
 *			and offers functions to access note annotation's properties and reset appearance of a note annotation. 
 *			It also offers function {@link FSNote::getReplyTo} to get the markup annotation, 
 *			to which the note annotation replies, if the note annotation is used as a reply.
 *
 * @note	For a newly created note annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly 
 *			without setting any properties, the default appearance will be used:<br>
 *			border color = 0xFFFFFF00 (yellow), opacity = 1.0, icon name = "Comment".
 *
 * @see FSMarkup
 */
@interface FSNote : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Get open status.
 *
 * @details	Open status is a boolean value that specifies whether a note annotation should initially be displayed open:
 *			<ul>
 *			<li><b>YES</b> means the note annotation should be initially be displayed open.</li>
 *			<li><b>NO</b> means the note annotation should be initially be displayed closed.</li>
 *			</ul>
 *
 * @return	Open status.
 */
-(BOOL)getOpenStatus;
/** 
 * @brief	Set open status.
 *
 * @details	Open status is a boolean value that specifies whether a note annotation should initially be displayed open:
 *			<ul>
 *			<li><b>YES</b> means the note annotation should be initially be displayed open.</li>
 *			<li><b>NO</b> means the note annotation should be initially be displayed closed.</li>
 *			</ul>
 *
 * @param[in]	status	The new open status value.
 *
 * @return	None.
 */
-(void)setOpenStatus: (BOOL)status;
/** 
 * @brief	Get icon name.
 * 
 * @details	Note annotation has predefined standard icon names: <br>
 *			"Checkmark", "Circle", "Comment", "Cross", "Help", 
 *			"Insert", "Key", "NewParagraph", "Note", "Paragraph", 
 *			"RightArrow", "RightPointer", "Star", "UpArrow", "UpleftArrow".<br>
 *
 * @return	Icon name string.
 */
-(NSString *)getIconName;
/** 
 * @brief	Set icon name. 
 *
 * @details	Note annotation has predefined standard icon names: <br>
 *			"Checkmark", "Circle", "Comment", "Cross", "Help", 
 *			"Insert", "Key", "NewParagraph", "Note", "Paragraph", 
 *			"RightArrow", "RightPointer", "Star", "UpArrow", "UpleftArrow".<br>
 *			For a new note annotation, if current function is not called, icon name will be "Comment" by default.
 *
 * @param[in]	iconName		New icon name string to be set. 
 *			
 * @return	None.
 */
-(void)setIconName: (NSString *)iconName;
/** 
 * @brief	Get the markup annotation, which current note annotation is in reply to.
 *
 * @details	This function is only useful when current note annotation is used as a reply.
 *
 * @return	A markup annotation object, which current note annotation is in reply to.
 *			If current note annotation is not used as a reply, this function will return <b>nil</b>.
 */
-(FSMarkup*)getReplyTo;
/**
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 *@brief	Class to access a text markup annotation.
 *
 * @details	Text markup annotations appear as highlights, underlines, strikeouts, 
 *			or squiggly lines in the text of a document.<br>
 *			Class <CODE>TextMarkup</CODE> is a base class for all PDF text markup annotations. It offers the basic functions
 *			to access text markup annotation's common properties. 
 *			Especially, for a text markup annotation, quadrilaterals are required. So please ensure that a text markup annotation 
 *			has valid quadrilaterals before resetting its appearance stream. 
 *			For concrete text markup annotation types, please refer to derived classes.
 */
@interface FSTextMarkup : FSMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the count of quadrilaterals.
 *
 * @return	The count of quadrilaterals.
 */
-(int)getQuadPointsCount;
/** 
 * @brief	Get a quadrilaterals by index.
 *
 * @details	The order of points in a quadrilateral should be:
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *
 * @param[in]	index		The index of a quadrilateral. Valid range: 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSTextMarkup::getQuadPointsCount}.
 *
 * @return	The specified quadrilaterals.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSQuadPoints*)getQuadPoints: (int)index;
/** 
 * @brief	Set quadrilaterals.
 *
 * @details	For a text markup annotation, quadrilaterals are required.
 *			After setting new quadrilaterals, rectangle of current text markup annotation will be updated as well. <br>
 *			The order of points in a quadrilateral should be:
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *
 *
 * @param[in]	quadPoints		A valid quadrilateral array. It should contains at least one valid quadrilateral.
 *
 * @return	None.
 */
-(void)setQuadPoints: (NSArray*)quadPoints;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a highlight annotation.
 * 
 * @details	Highlight annotation is a kind of text markup annotation, which is shown as 
 *			a highlight area for the text in a PDF document. 
 *			Class ::FSHighlight is derived from ::FSTextMarkup 
 *			and offers functions to reset appearance of a highlight annotation.
 *
 * @note	For a newly created highlight annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly 
 *			after setting required quadrilaterals property and not setting any other properties, 
 *			the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FS_BORDERSTYLE::e_borderStyleSolid}, 
 *			border color = 0xFFFFED00 (a kind of yellow), opacity = 1.0, 
 *
 * @see FSTextMarkup
 */
@interface FSHighlight : FSTextMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a highlight annotation, please ensure this highlight annotation has valid quadrilaterals;
 *			otherwise this highlight annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a underline annotation.
 * 
 * @details	Underline annotation is a kind of text markup annotation, which is shown as 
 *			a underline under the text in a PDF document. 
 *			Class ::FSUnderline is derived from ::FSTextMarkup 
 *			and offers functions to reset appearance of a underline annotation.
 *
 * @note	For a newly created underline annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly 
 *			after setting required quadrilaterals property and not setting any other properties, 
 *			the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FS_BORDERSTYLE::e_borderStyleSolid}, 
 *			border color = 0xFF339E00 (a kind of green), opacity = 1.0, 
 *
 * @see FSTextMarkup
 */
@interface FSUnderline : FSTextMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Reset appearance stream.
 *
 * @details	Before resetting appearance stream of a underline annotation, please ensure this underline annotation has valid quadrilaterals;
 *			otherwise this underline annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a strikeout annotation.
 * 
 * @details	StrikeOut annotation is a kind of text markup annotation, which is shown as 
 *			a strikeout line in the middle of the text in a PDF document. 
 *			Class ::FSStrikeOut is derived from ::FSTextMarkup 
 *			and offers functions to reset appearance of a strikeout annotation.
 *
 * @note	For a newly created strikeout annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly 
 *			after setting required quadrilaterals property and not setting any other properties, 
 *			the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FS_BORDERSTYLE::e_borderStyleSolid}, 
 *			border color = 0xFFF94244 (a kind of red), opacity = 1.0, 
 *
 * @see FSTextMarkup
 */
@interface FSStrikeOut : FSTextMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Reset appearance stream.
	 *
 * @details	Before resetting appearance stream of a strikeout annotation, please ensure this strikeout annotation has valid quadrilaterals;
 *			otherwise this strikeout annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a squiggly annotation.
 * 
 * @details	Squiggly annotation is a kind of text markup annotation, which is shown as 
 *			a squiggly line under the text in a PDF document. 
 *			Class ::FSSquiggly is derived from ::FSTextMarkup 
 *			and offers functions to reset appearance of a squiggly annotation.
 *
 * @note	For a newly created squiggly annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly 
 *			after setting required quadrilaterals property and not setting any other properties, 
 *			the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FS_BORDERSTYLE::e_borderStyleSolid}, 
 *			border color = 0xFF4899FF (a kind of blue), opacity = 1.0, 
 *
 * @see FSTextMarkup
 */
@interface FSSquiggly : FSTextMarkup
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Reset appearance stream.
	  *
 * @details	Before resetting appearance stream of a squiggly annotation, please ensure this squiggly annotation has valid quadrilaterals;
 *			otherwise this squiggly annotation cannot be reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Class to access a link annotation.
 *
 * @details	A link annotation represents an action to be performed.<br>
 *			Class ::FSLink is derived from ::FSAnnot 
 *			and offers functions to access link annotation's properties 
 *			and reset appearance stream of a link annotation. 
 *
 * @note	For a newly created link annotation, if user calls function {@link FSAnnot::resetAppearanceStream} directly 
 *			without setting any other properties, the default appearance will be used:<br>
 *			border width = 1.0, border style = {@link FS_BORDERSTYLE::e_borderStyleSolid}, 
 *			border color = 0xFFFF0000 (red), opacity = 1.0, 
 *			highlighting mode = {@link FS_HIGHLIGHTINGMODE::e_highlightingModeNone}.
 *
 * @see FSAnnot
 */
@interface FSLink : FSAnnot
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Reset appearance stream.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)resetAppearanceStream;
/** 
 * @brief	Get the count of quadrilaterals.
 *
 * @return	The count of quadrilaterals.
 */
-(int)getQuadPointsCount;
/** 
 * @brief	Get a quadrilateral by index.
 *
 * @details The order of points in a quadrilateral should be:
 *			<ul>
 *			<li>The first point is the point in left-top corner of the quadrilateral.</li>
 *			<li>The second point is the point in right-top corner of the quadrilateral.</li>
 *			<li>The third point is the point in left-bottom corner of the quadrilateral.</li>
 *			<li>The fourth point is the point in right-bottom corner of the quadrilateral.</li>
 *			</ul>
 *
 * @param[in]	index		The index of a quadrilateral. Valid range: 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSLink::getQuadPointsCount}.
 *
 * @return	The specified quadrilaterals.
 *			If there is any error, <b>nil</b> would be returned.
 */
-(FSQuadPoints*)getQuadPoints: (int)index;
/**
 * @brief	Get highlighting mode.
 *
 * @return	Highlighting mode value. Please refer to {@link FS_HIGHLIGHTINGMODE::e_highlightingModeNone FS_HIGHLIGHTINGMODE::e_highlightingModeXXX} values 
 *			and it would be one of these values except {@link FS_HIGHLIGHTINGMODE::e_highlightingModeToggle}.
 *			-1 means no highlighting mode value is found or error.
 */
-(enum FS_HIGHLIGHTINGMODE)getHighlightingMode;
/**
 * @brief	Get action.
 *
 * @return	An action instance.
 *			<b>nil</b> means no action or failure.
 */
-(FSAction*)getAction;

/** @brief Free the object. */
-(void)dealloc;

@end


/************************************************************************************************
 *									Bookmark													*
 *************************************************************************************************/

/**
 * @brief	Enumeration for bookmark style type.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_BOOKMARKSTYLE
{
	/** @brief	 Show bookmark title as normal text. */
	e_bookmarkStyleNormal = 0x00,
	/** @brief	 Show bookmark title as italic text. */
	e_bookmarkStyleItalic = 0x01,
	/** @brief	 Show bookmark title as bold text. */
	e_bookmarkStyleBold = 0x02
};
	
	
/** 
 * @brief	Class to access PDF bookmark.
 * 
 * @details	PDF bookmark is also called "outline". It's a tree-structured hierarchy. It allows user to navigate PDF document easily by selecting one outline.
 *			One bookmark contains a destination or actions to indicate how to response when user selects it.<br>
 *			In order to access the bookmark tree, function {@link FSPDFDoc::getFirstBookmark} must be called first to get the root of the whole bookmark tree.
 *			Here, "root bookmark" is an abstract object. "root bookmark" can only have some child bookmarks but no parent, no next sibling bookmarks or any data 
 *			(including bookmark data, destination data and action data). And "root bookmark" cannot be shown on the application UI since it has no data.
 *			So, for a root bookmark, only function {@link FSBookmark::getFirstChild} can be used.<br>
 *			From the root bookmark, the bookmark tree can be traversed and each bookmark node can be accessed.<br>
 *			This class offers several functions to access other bookmarks from current bookmark. For example:
 *			<ul>
 *			<li>To access the parent bookmark, use function {@link FSBookmark::getParent}.</li>
 *			<li>To access the first child bookmark, use function {@link FSBookmark::getFirstChild}.</li>
 *			<li>To access the next sibling bookmark, use function {@link FSBookmark::getNextSibling}.</li>
 *			</ul>
 *			This class also offers functions to access the data of a PDF bookmark.
 *
 * @see FSPDFDoc
 */
@interface FSBookmark : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Get the parent bookmark.
 *
 * @return	The parent bookmark instance.
 */
-(FSBookmark*)getParent;
/**
 * @brief	Get the first child bookmark.
 *
 * @return	The first child bookmark instance.
 */
-(FSBookmark*)getFirstChild;
/**
 * @brief	Get the next sibling bookmark.
 *
 * @return	The next sibling bookmark instance.
 */
-(FSBookmark*)getNextSibling;
/** 
 * @brief	Get the destination of the bookmark.
 *
 * @details	If current bookmark dictionary has /Dest or a goto action (/A), this function can get the destination information directly.
 *			If current bookmark dictionary does not have /Dest or its /A is not a goto action, 
 *			no destination information can be retrieved and this function will return <b>nil</b>.
 *
 * @return	The destination instance.
 */
-(FSDestination*)getDestination;
/**
 * @brief	Set the destination.
 *
 * @param[in]	dest	The new destination.
 *
 * @return	None.
 */
-(void)setDestination: (FSDestination*)dest;
/**
 * @brief	Get the title.
 *
 * @return	Title string.
 */
-(NSString *)getTitle;
/**
 * @brief	Set the title.
 *
 * @param[in]	title	New title string.
 *
 * @return	None.
 */
-(void)setTitle: (NSString *)title;
/**
 * @brief	Get the color.
 *
 * @return	Color used for displaying title. 
 *			Format: 0xAARRGGBB. Alpha value is ignored and will always be 0xFF by default.
 */
-(unsigned int)getColor;
/** 
 * @brief	Set the color.
 *
 * @param[in]	color	Color used for displaying title. Format:0xAARRGGBB.
 *						Alpha value is ignored and will always be treated as 0xFF internally.
 *
 * @return	None.
 */
-(void)setColor: (unsigned int)color;
/**
 * @brief	Get bookmark style.
 *
 * @return	The bookmark style values. 
 *			This would be one or a combination of {@link FS_BOOKMARKSTYLE::e_bookmarkStyleNormal FS_BOOKMARKSTYLE::e_bookmarkStyleXXX} values.
 */
-(unsigned int)getStyle;
/** 
 * @brief	Set bookmark style.
 *
 * @param[in]	style	The style of the bookmark. This can be one or a combination of {@link FS_BOOKMARKSTYLE::e_bookmarkStyleNormal FS_BOOKMARKSTYLE::e_bookmarkStyleXXX} values.
 *						If the <i>style</i> is invalid, {@link FS_BOOKMARKSTYLE::e_bookmarkStyleNormal} will be set instead.
 *
 * @return	None.
 */
-(void)setStyle: (unsigned int)style;

/** @brief Free the object. */
-(void)dealloc;

@end


/************************************************************************************************
 *									PDF Document					  							*
 *************************************************************************************************/
/**
 * @brief	Enumeration for page label style.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_PAGELABELSTYLE {
	/** @brief	Page label style: no numbering style. */
	e_pageLabelStyleNone	 =	0,
	/** @brief	Page label style: decimal Arabic numerals. */
	e_pageLabelStyleDecimalNums	=	1,
	/** @brief	Page label style: uppercase roman numerals. */
	e_pageLabelStyleUpperRomanNums	=	2,
	/** @brief	Page label style: lowercase roman numerals. */
	e_pageLabelStyleLowerRomanNums	=	3,
	/** @brief	Page label style: uppercase letters (A to Z for the first 26 pages, AA to ZZ for the next 26, and so on). */
	e_pageLabelStyleUpperLetters =	4,
	/** @brief	Page label style: lowercase letters (a to z for the first 26 pages, aa to zz for the next 26, and so on). */
	e_pageLabelStyleLowerLetters =	5
};


/**
 * @brief	Enumeration for password type.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_PASSWORDTYPE {
	/** @brief	The password is invalid. */
	e_pwdInvalid	 =	0,
	/** @brief	No password is used in PDF document. */
	e_pwdNoPassword	=	1,
	/** @brief	A user password is used in PDF document. */
	e_pwdUser	=	2,
	/** @brief	An owner password is used in PDF document. */
	e_pwdOwner	=	3
};


/**
 * @brief	Enumeration for encryption type.
 *
 * @details	Values of this enumeration should be used alone.
 */
enum FS_ENCRYPTTYPE {
	/** @brief	No encryption pattern. */
	e_encryptNone	 =	0,
	/** @brief	Encryption type: password, which is the standard encryption. */
	e_encryptPassword	=	1,
	/** @brief	Encryption type: digital certificate encryption. */
	e_encryptCertificate	=	2,
	/** @brief	Encryption type: Foxit DRM encryption. */
	e_encryptFoxitDRM	=	3,
	/** @brief	Encryption type: customized encryption. */
	e_encryptCustom	=	4,
	/** @brief	Encryption type: Microsoft RMS encryption. */
	e_encryptRMS	=	5
};
	
	
/**
 * @brief	Enumeration for user permissions of a PDF document.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
	
enum FS_USERPERMISSIONS {
	/**
	 * @brief	Print PDF document with normal mode. (Bit 3 in permission value)
	 * 
	 * @details	If user wants to print a higher quality level of PDF document, please set current value with {@link FS_USERPERMISSIONS::e_permPrintHigh} together.
	 */
	e_permPrint = 0x0004,
	/**
	 * @brief	Modify PDF contents. (Bit 4 in permission value)
	 * 
	 * @details	If this value is set, user can modify contents of PDF document 
	 *			by operations other than those controlled by {@link FS_USERPERMISSIONS::e_permAnnotForm}, {@link FS_USERPERMISSIONS::e_permFillForm} and {@link FS_USERPERMISSIONS::e_permAssemble} values.
	 */
	e_permModify	= 0x0008,
	/**
	 * @brief	Extract PDF contents. (Bit 5 in permission value)
	 * 
	 * @details	If this value is set, user can copy or otherwise extract text and graphics from the document 
	 *			by operations other than that controlled by {@link FS_USERPERMISSIONS::e_permExtractAccess} value. 
	 */
	e_permExtract = 0x0010,
	/**
	 * @brief	Operate text annotations and fill in interactive form fields. (Bit 6 in permission value)
	 * 
	 * @details	If {@link FS_USERPERMISSIONS::e_permModify} is also set, user can create or modify interactive form fields (including signature fields).
	 */
	e_permAnnotForm = 0x0020,
	/**
	 * @brief	Fill PDF form. (Bit 9 in permission value)
	 * 
	 * @details	If this value is set, user can fill in interactive form fields (including signature fields), 
	 * 			even if {@link FS_USERPERMISSIONS::e_permAnnotForm} is not used. 
	 */
	e_permFillForm = 0x0100,
	/** 
	 * @brief	Disabilities support. (Bit 10 in permission value)
	 * 
	 * @details	If this value is set, user can extract text and graphics in support of accessibility to users with disabilities 
	 *			or for other purposes. 
	 */
	e_permExtractAccess = 0x0200,
	/**
	 * @brief	Assemble PDF document. (Bit 11 in permission value)
	 * 
	 * @details	If this value is set, it enables to assemble the document (insert, rotate, or delete pages 
	 * 			and create bookmarks or thumbnail images), regardless if {@link FS_USERPERMISSIONS::e_permModify} is set or not. 
	 */
	e_permAssemble = 0x0400,
	/**
	 * @brief	Print PDF document with higher qualities. (Bit 12 in permission value)
	 * 
	 * @details	If this value is not set (and {@link FS_USERPERMISSIONS::e_permPrint} is set), printing is limited to a low-level 
	 * 			representation of the appearance, possibly of degraded quality. 
	 */
	e_permPrintHigh = 0x0800
};
	
	

/**
* @brief	Class to represent information of a page labeling range.
*
* @details	Page label is used to identify each page visually on the screen or in print, 
*			and can be specified in any way that is appropriate for the particular document.<br>
*			For purposes of page labeling, a document can be divided into labeling ranges, 
*			each of which is a series of consecutive pages using the same numbering system. 
*			Pages within a range are numbered sequentially in ascending order. 
*			A page's label consists of a numeric portion based on its position within its labeling range, 
*			optionally preceded by a label prefix denoting the range itself. <br>
*			For example, the pages in an appendix might be labeled with decimal numeric portions prefixed 
*			with the string A-; the resulting page labels would be A-1, A-2, and so on.<br>
*			This class represents the information of a page labeling range, including numbering style, label prefix 
*			and value of the numeric portion for the first page label in the range.<br>
 */
@interface FSPageLabel : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Set value.
 *
 * @param[in]	start				The index of first page in current labeling range, starting from 0.
 * @param[in]	style				The numbering style to be used for the numeric portion of each page label.
 *									Please refer to {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone FS_PAGELABELSTYLE::e_pageLabelStyleXXX} and it should be one of these values.
 *									If the value is {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone}, page labels consist solely of a label prefix with no numeric portion.
 * @param[in]	prefix				The label prefix string for page labels in current labeling range. 
 *									Only the first 100 characters can be used as label prefix string.
 * @param[in]	firstPageNumber		The value of the numeric portion for the first page label in current labeling range.
 *									Subsequent pages are numbered sequentially from this value, which must be greater than or equal to 1.
 *
 * @return	None.
 */
-(void)set: (int)start style: (enum FS_PAGELABELSTYLE)style prefix: (NSString *)prefix firstPageNumber: (int)firstPageNumber;
/** 
 * @brief	Set the index of first page in current labeling range.
 *
 * @param[in]	value	New index for first page. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is the page count of the PDF document.
 *
 * @return	None.
 */
-(void)setStart: (int)value;
/** 
 * @brief	Get the index of first page in current labeling range.
 *
 * @return	The index for first page, starting from 0.
 */
-(int)getStart;
/** 
 * @brief	Set numbering style.
 *
 * @details	Numbering style is used for the numeric portion of each page label.
 *
 * @param[in]	value	New numbering style.
 *						Please refer to {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone FS_PAGELABELSTYLE::e_pageLabelStyleXXX} and it should be one of these values.
 *						If the value is {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone}, page labels consist solely of a label prefix with no numeric portion.
 *
 * @return	None.
 */
-(void)setStyle: (enum FS_PAGELABELSTYLE)value;
/** 
 * @brief	Get numbering style.
 *
 * @details	Numbering style is used for the numeric portion of each page label.
 * 
 * @return	The numbering style.
 *			Please refer to {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone FS_PAGELABELSTYLE::e_pageLabelStyleXXX} and it would be one of these values.
 *			If the value is {@link FS_PAGELABELSTYLE::e_pageLabelStyleNone}, page labels consist solely of a label prefix with no numeric portion.
 */
-(enum FS_PAGELABELSTYLE)getStyle;
/** 
 * @brief	Set label prefix.
 *
 * @param[in]	value	New label prefix string. 
 *						Only the first 100 characters can be used as label prefix string.
 *
 * @return	None.
 */
-(void)setPrefix: (NSString *)value;
/** 
 * @brief	Get label prefix.
 *
 * @return	Label prefix string.
 */
-(NSString *)getPrefix;
/** 
 * @brief	Set the value of the numeric portion for the first page label
 *
 * @details	Subsequent pages are numbered sequentially from this value, 
 *			which must be greater than or equal to 1
 *
 * @param[in]	value	New value of the numeric portion.
 *
 * @return	None.
 */
-(void)setFirstPageNumber: (int)value;
/** 
 * @brief	Get the value of the numeric portion for the first page label
 *
 * @details	Subsequent pages are numbered sequentially from this value, 
 *			which must be greater than or equal to 1
 *
 * @return	Value of the numeric portion.
 */
-(int)getFirstPageNumber;
/** @brief Initialize the object. */
-(id)init;

/** @brief Free the object. */
-(void)dealloc;

@end


/**
 * @brief	Enumeration for PDF document saving flags.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_SAVEFLAGS {
	/** @brief	Save document normally, without using any special flag. This can only be used alone.*/
	e_saveFlagNormal = 0,
	/**
	 * @brief	Save document incrementally. 
	 * 
	 * @details	This can be used alone or be combined with other saving flags except {@link FS_SAVEFLAGS::e_saveFlagNormal}.
	 *			Especially, if this is combined with {@link FS_SAVEFLAGS::e_saveFlagNoOriginal}, only the increment data will be saved.
	 */
	e_saveFlagIncremental = 0x0001,
	/**
	 * @brief	Save document without original data or unchanged objects. 
	 * 
	 * @details	This can be used alone or be combined with other saving flags except {@link FS_SAVEFLAGS::e_saveFlagNormal}.
	 *			Especially, if this is combined with {@link FS_SAVEFLAGS::e_saveFlagIncremental}, only the increment data will be saved.
	 */
	e_saveFlagNoOriginal = 0x0002,
	/**
	 * @brief	Save document by using object stream, in order to reduce the file size. 
	 * 
	 * @details	This can be used alone or be combined with other saving flags except {@link FS_SAVEFLAGS::e_saveFlagNormal}.
	 */
	e_saveFlagObjectStream = 0x0004
};
	


/**
 * @brief	Class to access a PDF document.
 *
 * @details	A <CODE>PDFDoc</CODE> object can be created by following functions:
 *			<ul>
 *			<li>{@link FSPDFDoc::createFromFilePath:}: from a specified PDF file path.</li>
 *			<li>{@link FSPDFDoc::createFromMemory:}: from memory buffer which contains the serialized document.</li>
 *			<li>{@link FSPDFDoc::createFromHandler:}: from a customized <CODE>FileRead</CODE> object.</li>
 *			</ul>
 *			After a <CODE>PDFDoc</CODE> object is created, function {@link FSPDFDoc::load:} should be called to load the document content.<br>
 *			This class also offers functions to access different part of a PDF document. For example:
 *			<ul>
 *			<li>To access pages, use functions {@link FSPDFDoc::getPageCount} and {@link FSPDFDoc::getPage:}.</li>
 *			<li>To access bookmark tree, use function {@link FSPDFDoc::getFirstBookmark}.</li>
 *			<li>To access document information (that is "metadata"), use functions {@link FSPDFDoc::hasMetadataKey:}, {@link FSPDFDoc::getCreationDateTime}, 
 *				{@link FSPDFDoc::getModifiedDateTime} and {@link FSPDFDoc::getMetadataValue:}.</li>
 *			<li>To access page labeling range information , use functions {@link FSPDFDoc::getPageLabelRangeCount} and {@link FSPDFDoc::getPageLabelInfo:}.</li>
 *			<li>To access document catalog dictionary (in low-level), use function {@link FSPDFDoc::getCatalog}.</li>
 *			<li>To access document trailer dictionary (in low-level), use function {@link FSPDFDoc::getTrailer}.</li>
 *			<li>To access document information dictionary (in low-level), use function {@link FSPDFDoc::getInfo}.</li>
 *			<li>To access document encrypt dictionary (in low-level), use function {@link FSPDFDoc::getEncryptDict}.</li>
 *			</ul>
 *
 * @see FSPDFPage
 * @see FSBookmark
 * @see FSPageLabel
 * @see FSPDFDictionary
 */
@interface FSPDFDoc : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a PDF document object with an existing PDF document from file path.
 *
 * @param[in]	path	Path name of the PDF file.
 * 
 * @return	A new PDF document instance.
 */
+(FSPDFDoc*)createFromFilePath: (NSString *)path;
/** 
 * @brief	Create a PDF document object with a memory buffer.
 *
 * @param[in]	buffer		A memory buffer, containing the serialized document.
 *							The PDF document data should be fully loaded in the memory buffer.<br>
 *							The memory buffer ownership is not transferred to the PDF document object, 
*							so when the document is not used any more, user should clean-up allocated memory if necessary. 
 *
 * @return	A new PDF document instance.
 */
+(FSPDFDoc*)createFromMemory: (NSData *)buffer;
/** 
 * @brief	Create a document object with a file read instance.
 *
 * @param[in]	fileRead	A file read instance which is implemented by user to load a PDF document.
 * 
 * @return	A new PDF document instance.
 */
+(FSPDFDoc*)createFromHandler: (FSFileReadCallback*)fileRead;
/** 
 * @brief	Load current document content by using the specified password.
 *
 * @param[in]	password		The password string, used to load current document content. It can be either user password or owner password.
 *								If current document is not encrypted by password, just pass an empty string.
 *
 * @return	{@link FS_ERRORCODE::e_errSuccess} means success. <br>
 *			{@link FS_ERRORCODE::e_errFile} means there is any error occurs when accessing to current document content.<br>
 *			{@link FS_ERRORCODE::e_errFormat} means the format of current document content is not PDF or the file is corrupted.<br>
 *			{@link FS_ERRORCODE::e_errSecurityHandler} means current PDF document is encrypted by some unsupported security handler.<br>
 *			{@link FS_ERRORCODE::e_errCertificate} means current PDF document is encrypted by digital certificate and current user does not have the correct certificate. <br>
 *			For other error code value, please refer to {@link FS_ERRORCODE::e_errSuccess FS_ERRORCODE::e_errXXX} for more details.
 */
-(enum FS_ERRORCODE)load: (NSString *)password;
/** 
 * @brief	Check whether current document is an encrypted file or not.
 * 
 * @return	<b>YES</b> means current document is an encrypted file, while <b>NO</b> means current document is not an encrypted file.
 */
-(BOOL)isEncrypted;
/** 
 * @brief	Check whether current document has been modified or not.
 *
 * @return	<b>YES</b> means current document has been modified, while <b>NO</b> means current document has not been modified.
 */
-(BOOL)isModified;
/**
 * @brief	Get the encryption type.
 *
 * @return	Encryption type.
 *			Please refer to {@link FS_ENCRYPTTYPE::e_encryptNone FS_ENCRYPTTYPE::e_encryptXXX} values and it would be one of these values.
 */
-(enum FS_ENCRYPTTYPE)getEncryptionType;
/**
 * @brief	For the password protected document, get the type of password, which is used when loading document content in function FSPDFDoc::load.
 *
 * @return	Password type. 
 *			Please refer to {@link FS_PASSWORDTYPE::e_pwdInvalid FS_PASSWORDTYPE::e_pwdXXX} values and it would be one of these values.
 */
-(enum FS_PASSWORDTYPE)getPasswordType;
/** 
 * @brief	For the password protected document, check the type of a specified password.
 *
 * @details	This function can be used to check the type of any password string.
 *
 * @param[in]	password		The password string to be checked.
 *
 * @return	Password type. 
 *			Please refer to {@link FS_PASSWORDTYPE::e_pwdInvalid FS_PASSWORDTYPE::e_pwdXXX} values and it would be one of these values.
 */
-(enum FS_PASSWORDTYPE)checkPassword: (NSString *)password;
/**
 * @brief	Save current PDF document as another PDF file.
 * 
 * @param[in]	filePath		File path for the new saved PDF file.
 * @param[in]	saveFlags		Document saving flags. 
 *								Please refer to {@link FS_SAVEFLAGS::e_saveFlagNormal FS_SAVEFLAGS::e_saveFlagXXX} values and this can be one or combination of these values.
 *
 * @return	<b>YES</b> means the saving is successfully finished, while <b>NO</b> means failure.
 */
-(BOOL)saveAs: (NSString *)filePath saveFlags:(unsigned int)saveFlags;
/**
 * @brief	Get the first bookmark.
 *
 * @return	The first bookmark.
 */
-(FSBookmark*)getFirstBookmark;
/** 
 * @brief	Get the count of pages.
 *
 * @return	The count of page.
 */
-(int)getPageCount;
/** 
 * @brief	Get a PDF page by index.
 *
 * @param[in]	pageIndex	The page index. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return	A PDF page instance. 
 *			If the page instance is not used any more, please call function {@link FSPDFDoc::closePage:} to close it.
 */
-(FSPDFPage*)getPage: (int)pageIndex;
/** 
 * @brief	Close a PDF page by page index.
 *
 * @param[in]	pageIndex	The page index. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageCount}.
 * 
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)closePage: (int)pageIndex;
/**  
 * @brief	Get the display mode.
 *
 * @details	Display mode specifies how the document should be displayed when opened.
 *
 * @return	Display mode value.
 *			Please refer to {@link FS_DISPLAYMODE::e_displayUseNone FS_DISPLAYMODE::e_displayUseXXX} values and this would be one of its values.
 */
-(enum FS_DISPLAYMODE)getDisplayMode;
/**  
 * @brief	Get the catalog dictionary.
 *
 * @return	The catalog dictionary.
 */
-(FSPDFDictionary*)getCatalog;
/** 
 * @brief	Get the trailer dictionary.
 *
 * @return	The trailer dictionary.
 */
-(FSPDFDictionary*)getTrailer;
/** 
 * @brief	Get the information dictionary.
 *
 * @details	Document's information dictionary contains metadata for the document.
 * 
 * @return	The information dictionary.
 */
-(FSPDFDictionary*)getInfo;
/** 
 * @brief	Get the encrypt dictionary.
 *
 * @return	The encrypt dictionary.
 */
-(FSPDFDictionary*)getEncryptDict;
/** 
 * @brief	Get an indirect object by indirect object number.
 *
 * @param[in]	objnum		The indirect object number. It should be above 0.
 *
 * @return	A ::FSPDFObject object that receives the indirect PDF object.
 *			<b>nil</b> means not found or there is any error.
 */
-(FSPDFObject*)getIndirectObject: (unsigned int)objnum;
/** 
 * @brief	Add a PDF object to current PDF document, to be an indirect object.
 *
 * @details	<ul>
 *			<li>If input PDF object is a direct object (whose indirect object number is 0), 
 *				this functions will change it to be an indirect object and add to PDF document.
 *				Then return the new indirect object number.</li>
 *			<li>If input PDF object is already an indirect object (whose indirect object number is above 0), 
 *				this function will not add it into document again.
 *				The return value will be its own indirect object number.</li>
 *			</ul>
 *
 * @param[in]	obj		A PDF object instance.
 *
 * @return	The new indirect object number. 
 *			If there is any error, 0 will be returned.
 */
-(unsigned int)addIndirectObject: (FSPDFObject*)obj;
/** 
 * @brief	Delete an indirect object by indirect object number.
 *
 * @param[in]	objnum		The indirect object number. It should be above 0.
 *
 * @return	None.
 */
-(void)deleteIndirectObject: (unsigned int)objnum;
/** 
 * @brief	Get user access permissions.
 * 
 * @return	User access permission.
 *			Please refer to {@link FS_USERPERMISSIONS::e_permPrint FS_USERPERMISSIONS::e_permXXX} values and this would be one or combination of its values.
 */
-(unsigned int)getUserPermissions;
/** 
 * @brief	Check whether current document has a specified metadata key or not.
 *
 * @param[in]	key		The metadata key to be confirmed.
 *
 * @return	<b>YES</b> means current document has the specified metadata key, 
 *			while <b>NO</b> means current document does not have the specified metadata key.
 */
-(BOOL)hasMetadataKey: (NSString *)key;
/** 
 * @brief	Get creation date time.
 * 
 * @return	The creation date time.
 *			If no creation date time can be found or any error occurs, <b>nil</b> will be returned.
 */
-(FSDateTime*)getCreationDateTime;
/** 
 * @brief	Get modified date time.
 * 
 * @return	The modified date time.
 *			If no modified date time can be found or any error occurs, <b>nil</b> will be returned.
 */
-(FSDateTime*)getModifiedDateTime;
/** 
 * @brief	Get metadata value.
 *
 * @param[in]	key		Metadata key string. Currently it can be one of the following keys:<br>
 *						<ul>
 *						<li>"Title"</li> 
 *						<li>"Author"</li>
 *						<li>"Subject"</li>
 *						<li>"Keywords"</li>
 *						<li>"Creator"</li>
 *						<li>"Producer"</li>
 *						<li>"Trapped"</li>
 *						<li>"pdfaid"</li>
 *						</ul>
 *
 * @return	Metadata value string.
 */
-(NSString *)getMetadataValue: (NSString *)key;
/**
 * @brief	Get count of ranges of page labels, which use different numbering systems.
 *
 * @return	The count of the page label range.
 */
-(int)getPageLabelRangeCount;
/** 
 * @brief	Get information of a specified page label.
 *
 * @param[in]	index		The index of the page label range to get the information.
 *							Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFDoc::getPageLabelRangeCount}.
 *
 * @return	The page label information.
 *			If any error occurs, <i>nil</i> will be returned.
 */
-(FSPageLabel*)getPageLabelInfo: (int)index;

/** @brief Free the object. */
-(void)dealloc;

@end


/** 
 * @brief	Enumeration for PDF object type.
 * 
 * @details	Values of this enumeration can be used alone.
 */
enum FS_PDFOBJECTTYPE {
	/** @brief	Invalid PDF object type. */
	e_objInvalidType = 0,
	/** @brief	PDF object type for boolean. */
	e_objBoolean = 1,
	/** @brief	PDF object type for number. */
	e_objNumber = 2,
	/** @brief	PDF object type for string. */
	e_objString = 3,
	/** @brief	PDF object type for name. */
	e_objName = 4,
	/** @brief	PDF object type for array. */
	e_objArray = 5,
	/** @brief	PDF object type for dictionary. */
	e_objDictionary = 6,
	/** @brief	PDF object type for stream. */
	e_objStream = 7,
	/** @brief	PDF object type for a null object. */
	e_objNull = 8,
	/** @brief	PDF object type for a reference object. */
	e_objReference = 9
};
	

/** 
 * @brief	Class to access a PDF object.
 *
 * @details	PDF supports eight basic types of objects: <br>
 *			"Boolean value", "Integer and real number", "String", "Name", 
 *			"Array", "Dictionary",  "Stream", "The null object".<br>
 *			If user wants to make a newly created PDF object to be an indirect object, please call function {@link FSPDFDoc::addIndirectObject:}.
 *			For more details about PDF objects, please refer to <PDF Reference 1.7> Section 3.2 Objects.<br>
 *			Class ::FSPDFObject is a base class for all kinds of PDF objects. It offers different functions to create different kind of PDF objects.
 *			For "Array", "Dictionary" and "Stream" PDF object, please refer to derived classes ::FSPDFArray, ::FSPDFDictionary and ::FSPDFStream. 
 * 
 * @see FSPDFArray
 * @see FSPDFDictionary
 * @see FSPDFStream
 */
@interface FSPDFObject : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Create a PDF object from a boolean value.
 *
 * @param[in]	boolean		A boolean value.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objBoolean}.
 */
+(FSPDFObject*)createFromBoolean: (BOOL)boolean;
/** 
 * @brief	Create a PDF object from a float number.
 *
 * @param[in]	f		A float value.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objNumber}.
 */
+(FSPDFObject*)createFromFloat: (float)f;
/** 
 * @brief	Create a PDF object from a integer number.
 *
 * @param[in]	integer		An integer value.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objNumber}.
 */
+(FSPDFObject*)createFromInteger: (int)integer;
/** 
 * @brief	Create a PDF object from string.
 *
 * @param[in]	string	A string value.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objString}.
 */
+(FSPDFObject*)createFromString: (NSString *)string;
/** 
 * @brief	Create a PDF object from a string which represents a name.
 *
 * @param[in]	name	A name string.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objName}.
 */
+(FSPDFObject*)createFromName: (NSString *)name;
/** 
 * @brief	Create a PDF object from date time.
 *
 * @details	PDF defines a standard date format, which closely follows that of the 
 *			international standard ASN.1 (Abstract Syntax Notation One), defined in ISO/
 *			IEC 8824 (see the Bibliography). A date is an ASCII string of the form
 *			(D:YYYYMMDDHHmmSSOHH'mm')
 *
 * @param[in]	dateTime	A date time instance.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objString}.
 */
+(FSPDFObject*)createFromDateTime: (FSDateTime*)dateTime;
/** 
 * @brief	Create a reference for an indirect object.
 *
 * @details	The indirect object can be retrieved from following functions:
 *			<ul>
 *			<li>Returned by function {@link FSPDFDoc::getIndirectObject:}.</li>
 *			<li>Returned by function {@link FSPDFDoc::addIndirectObject:}, when try to add a direct PDF object to PDF document 
 *				and make it to be an indirect object.</li>
 *			</ul>
 *
 * @param[in]	pDoc	A PDF document instance.
 * @param[in]	objnum	The indirect object number of the indirect PDF object. This should be above 0.
 *
 * @return	A new PDF object instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objReference}.
 */
+(FSPDFObject*)createReference: (FSPDFDoc*)pDoc objnum: (unsigned int)objnum;
/** 
 * @brief	Clone current PDF object and get the clone result.
 *
 * @return	A new PDF object instance as the clone result.
 */
-(FSPDFObject*)cloneObject;
/** 
 * @brief	Get the type of current PDF object.
 *
 * @return	A value represents the object type. Please refer to {@link FS_PDFOBJECTTYPE::e_objBoolean FS_PDFOBJECTTYPE::e_objXXX} values and it would be one of these values.
 */
-(enum FS_PDFOBJECTTYPE)getType;
/** 
 * @brief	Get the indirect object number of current PDF object.
 *
 * @return	The indirect object number:
 *			<ul>
 *			<li>0 for direct object.</li>
 *			<li>above 0 for indirect object.</li>
 *			<li>-1 means there is any error.</li>
 *			</ul>
 */
-(unsigned int)getObjNum;
/** 
 * @brief	Get the integer value of current PDF object. 
 *
 * @details	Only used when current object type is {@link FS_PDFOBJECTTYPE::e_objNumber}.
 *
 * @return	The integer value. -1 may also mean current PDF object type is not {@link FS_PDFOBJECTTYPE::e_objNumber}.
 */
-(int)getInteger;
/** 
 * @brief	Get the float value of current PDF object. 
 *
 * @details	Only used when current object type is {@link FS_PDFOBJECTTYPE::e_objNumber}.
 *
 * @return	The integer value. -1.0 may also mean current PDF object type is not {@link FS_PDFOBJECTTYPE::e_objNumber}.
 */
-(float)getFloat;
/** 
 * @brief	Get the boolean value of current PDF object. 
 *
 * @details	Only used when current object type is {@link FS_PDFOBJECTTYPE::e_objBoolean}.
 *
 * @return	The boolean value. <b>NO</b> may also mean current PDF object type is not {@link FS_PDFOBJECTTYPE::e_objBoolean}.
 */
-(BOOL)getBoolean;
/** 
 * @brief	Get the matrix value of current PDF object. 
 *
 * @details	Only used for a PDF array object when it has 6 number objects as elements.
 *
 * @return	A matrix instance.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSMatrix*)getMatrix;
/** 
 * @brief	Get the rectangle value of current PDF object.
 *
 * @details	Only used for a PDF array object when it has 4 number objects as elements.
 *
 * @return	A float rectangle instance.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSRectF*)getRect;
/** 
 * @brief	Get the direct object of current PDF object.
 *
 * @details	Only used when current object type is {@link FS_PDFOBJECTTYPE::e_objReference}.
 *
 * @return	A PDF object that represents the direct PDF object.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSPDFObject*)getDirectObject;
/** 
 * @brief	Get the date time value of current PDF object.
 *
 * @details	Only used when current object type is {@link FS_PDFOBJECTTYPE::e_objString} and its content is PDF standard date format.
 *
 * @return	A date time instance.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSDateTime*)getDateTime;
/**
 * @brief	Get the string value of current PDF object.
 * 
 * @details	This function will get the string format for actual value of current PDF object.<br>
 *			If object type is {@link FS_PDFOBJECTTYPE::e_objBoolean}, "true" or "false" string value will be returned, depending on its actual value.<br>
 *			If object type is {@link FS_PDFOBJECTTYPE::e_objNumber}, the value will be represents as a string. For example, "1.5" string is for value 1.5.<br>
 *			If object type is {@link FS_PDFOBJECTTYPE::e_objString} or {@link FS_PDFOBJECTTYPE::e_objName}, the string value will be retrieved directly.<br>
 *			If value of current PDF object cannot be converted to a valid string, an empty string will be returned.
 *
 * @return	String value.
 *			An empty string may also mean there is not valid string value or there is any error.
 */
-(NSString *)getString;

/** @brief Free the object. */
-(void)dealloc;

@end


/** 
 * @brief	Class to access a PDF stream object.
 *
 * @details	A PDF stream object consists of a direct dictionary object and stream data.<br>
 *			For more details, please refer to <PDF Reference 1.7> Section 3.2.7 Stream Objects.<br>
 *			Class ::FSPDFStream is derived from ::FSPDFObject 
 *			and offers functions to create a new PDF stream object and access stream data.
 *
 * @see FSPDFObject
 */
@interface FSPDFStream : FSPDFObject
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Create a new stream object based on a dictionary.
 *
 * @param[in]	dictionary	A PDF dictionary object. 
 *							If this is <b>nil</b>, stream object will be created based on an empty dictionary.
 *
 * @return	A new PDF stream object.
 */
+(FSPDFStream*)create: (FSPDFDictionary*)dictionary;
/** 
 * @brief	Get the dictionary object associated to current stream object.
 *
 * @return	The stream dictionary.
 */
-(FSPDFDictionary*)getDictionary;
/**
 * @brief	Get size of stream data, in bytes.
 *
 * @param[in]	rawData		A boolean value that indicates whether to get raw data or not: 
 *							<b>YES</b> means to get raw data, and <b>NO</b> means to get decoded data (original data).
 *
 * @return	The data size, in bytes.
 */
-(unsigned int)getDataSize: (BOOL)rawData;
/** 
 * @brief	Get stream data.
 *
 * @param[in]	rawData		A boolean value that indicates whether to get raw data or not: 
 *							<b>YES</b> means to get raw data, and <b>NO</b> means to get decoded data (original data).
 * @param[in]	bufLen		Size of the data that user wants to retrieve from current PDF stream object, in bytes.
 *							If this is larger than the actual stream data size returned by function {@link FSPDFStream::getDataSize:} (with same parameter <i>rawData</i>),
 *							the whole stream data will be retrieved.
 *
 * @return	Stream data.
 */
-(NSData *)getData: (BOOL)rawData bufLen: (int)bufLen;
/** 
 * @brief	Set stream data.
 *
 * @param[in]	buffer		New stream data.
 *
 * @return	None.
 */
-(void)setData: (NSData *)buffer;

/** @brief Free the object. */
-(void)dealloc;

@end


/** 
 * @brief	Class to access a PDF array object.
 *
 * @details	A PDF array object is a one-dimensional collection of objects arranged sequentially.
 *			Unlike arrays in many other computer languages, elements in a PDF array can be any combination of numbers, strings,
 *			dictionaries, or any other objects, including other arrays. <br>
 *			For more details, please refer to <PDF Reference 1.7> Section 3.2.5 Array Objects.<br>
 *			Class ::FSPDFArray is derived from ::FSPDFObject 
 *			and offers functions to create a new PDF array object and access elements of a PDF array object.
 *
 * @see FSPDFObject
 */
@interface FSPDFArray : FSPDFObject
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Create a new array object.
 *
 * @return	A new PDF array object.
 */
+(FSPDFArray*)create;
/** 
 * @brief	Create a new array object for a matrix.
 *
 * @param[in]	matrix	A matrix object.
 *
 * @return	A new PDF array object.
 */
+(FSPDFArray*)createFromMatrix: (FSMatrix*)matrix;
/** 
 * @brief	Create a new array object for a rectangle.
 *
 * @param[in]	rect	A float rectangle object.
 *
 * @return	A new PDF array object.
 */
+(FSPDFArray*)createFromRect: (FSRectF*)rect;
/** 
 * @brief	Get the count of elements.
 *
* @return	Count of elements. If there is any error, -1 will be returned.
 */
-(int)getElementCount;
/** 
 * @brief	Get a specific element by index.
 *
 * @param[in]	index	Index of the element to be retrieved. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFArray::getElementCount}.
 *
 * @return	A ::FSPDFObject object receives the element.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSPDFObject*)getElement: (int)index;
/** 
 * @brief	Add a PDF object to the end of current PDF array object.
 *
 * @param[in]	element		The PDF object to be added to array.
 *
 * @return	None.
 */
-(void)addElement: (FSPDFObject*)element;
/** 
 * @brief	Insert a PDF object to a specific position of current PDF array object.
 *
 * @param[in]	index		Index of the position where parameter <i>element</i> will be inserted to. 
 *							Valid range: from 0 to (<i>count</i>-1). <i>count</i> is returned by function {@link FSPDFArray::getElementCount}.
 *							If this is below 0 or count of element in current PDF array is 0, parameter <i>element</i> is to be inserted to the first position.<br>
 *							If this is larger than count of element in current PDF array, parameter <i>element</i> is to be added to the last.
 * @param[in]	element		The PDF object to be inserted to current PDF array.
 *
 * @return	None.
	 */
-(void)insertAt: (int)index element: (FSPDFObject*)element;
/**
 * @brief	Set a new PDF object at specific position in current PDF array object.
 *
 * @param[in]	index		Index of the position where parameter <i>element</i> will be set to. 
 *							Valid range: from 0 to (<i>count</i>-1). <i>count</i> is returned by function {@link FSPDFArray::getElementCount}.
 * @param[in]	element		The PDF object to be set to current PDF array.
 *
 * @return	None.
 */
-(void)setAt: (int)index element: (FSPDFObject*)element;
/**
 * @brief	Remove an element in a specific position(by index) from current PDF array object.
 *
 * @param[in]	index	Index of the position where the element will be removed.
 *						Valid range: from 0 to (<i>count</i>-1). <i>count</i> is returned by function {@link FSPDFArray::getElementCount}.
 *
 * @return	None.
 */
-(void)removeAt: (int)index;

/** @brief Free the object. */
-(void)dealloc;

@end


/** 
 * @brief	Class to access a PDF dictionary object.
 *
 * @details	A PDF dictionary object is an associative table containing pairs of objects, known as entries of the dictionary. 
 *			The first element of each entry is the key, and it must be a name PDF object.
 *			The second element is the value, and it can be any kind of PDF object, including another dictionary.
 *			In the same dictionary, no two entries should have the same key. <br>
 *			For more details, please refer to <PDF Reference 1.7> Section 3.2.6 Dictionary Objects.<br>
 *			Class ::FSPDFDictionary is derived from ::FSPDFObject 
 *			and offers functions to create a new PDF dictionary object and access entries in a PDF dictionary object.
 *
 * @see FSPDFObject
 */
@interface FSPDFDictionary : FSPDFObject
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Create a new dictionary object.
 *
 * @return	A new PDF dictionary instance, whose object type is {@link FS_PDFOBJECTTYPE::e_objDictionary}.
 */
+(FSPDFDictionary*)create;
/** 
 * @brief	Check whether there is an entry with specific key in current dictionary or not.
 *
 * @param[in]	key		The key to be checked.
 *
 * @return	<b>YES</b> means the specific key exist in current dictionary, while <b>NO</b> means not.
 *			<b>NO</b> may also mean there is any error.
 */
-(BOOL)hasKey: (NSString *)key;
/** 
 * @brief	Get the value element of an entry with specific key.
 *
 * @param[in]	key		The key of the entry.
 *
 * @return	A PDF object instance that represents the value element of the specific entry.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSPDFObject*)getElement: (NSString *)key;
/** 
 * @brief	Get the key of an entry specified by position. 
 *
 * @param[in]	pos		A position instance that specifies the position of the entry.
 *
 * @return	The key of the specific entry.
 *			If there is any error, an empty string will be returned.
 */
-(NSString *)getKey: (void*)pos;
/** 
 * @brief	Get the value element of an entry specified by position.
 *
 * @param[in]	pos		A position object that specifies the position of the entry.
 *
 * @return	A PDF object instance that receives the value element of the specific entry.
 *			If there is any error, <b>NULL</b> will be returned.
 */
-(FSPDFObject*)getValue: (void*)pos;
/** 
 * @brief	Move to the position of first or the next entry.
 *
 * @param[in]	pos		A position instance that indicates the position of current entry in the dictionary.
 *						If this is <b>NULL</b>, the position of first entry in the dictionary will be returned.
 *
 * @return	A new position instance that represents the position of next entry in the dictionary. 
 *			<b>nil</b> means current entry is the last in the dictionary, or there is any error.
 */
-(void*)moveNext: (void*)pos;
/** 
 * @brief	Set a PDF object as value element to an entry with specific key.
 *
 * @param[in]	key		The key of the entry, whose value element will be set.
 * @param[in]	object	A PDF object instance which will be set to the entry as value element.
 *
 * @return	None.
 */
-(void)setAt: (NSString *)key object: (FSPDFObject*)object;
/** 
 * @brief	Remove an entry with specific key.
 *
 * @param[in]	key		The key of the entry to be removed.
 *
 * @return	None.
 */
-(void)removeAt: (NSString *)key;

/** @brief Free the object. */
-(void)dealloc;

@end
	
	

/** 
 * @brief	Enumeration for Page parse status.
 * 
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_PAGEPARSEFLAG {
	/** @brief	PDF page parsing flag for normal mode. */
	e_parsePageNormal = 0x0000,
	/** @brief	PDF page parsing flag for text-only mode. */
	e_parsePageTextOnly = 0x0001,
	/** @brief	Parse the text content of PDF page with outputting the hyphen on a line feed.*/
	e_parseTextOutputHyphen = 0x0002
};

/** 
 * @brief	Enumeration for calculating margin mode.
 * 
 * @details	Values of this enumeration can be used alone.
 */
enum FS_CALCMARGINMODE {
	/** @brief	Calculate margin according to bounding box of all contents. */
	e_calcContentsBox = 0,
	/** @brief	Calculate margin by detecting paths or images. */
	e_calcDetection = 1
};

/** 
 * @brief	Class to access a PDF page.
 * 
 * @details	Usually, a ::FSPDFPage object is retrieved from a PDF document by function {@link FSPDFDoc::getPage:} 
 *			Function {@link FSPDFPage::isParsed} is used to judge whether the PDF page has been parsed or not. 
 *			For a un-parsed page, use function {@link FSPDFPage::startParse:pause:isReparse:} to parse it.<br>
 *			This class offers functions to access data of a PDF page, such as page width/height, page rotation, display matrix and so on.
 *			It also offers functions to access PDF annotations:
 *			<ul>
 *			<li>To get a PDF annotation, use function {@link FSPDFPage::getAnnot:}, {@link FSPDFPage::getAnnotAtPos:tolerance:}, 
 *				or {@link FSPDFPage::getAnnotAtDevicePos:position:tolerance:}.</li>
 *			<li>To add a new PDF annotation, use function {@link FSPDFPage::addAnnot:rect:}.</li>
 *			<li>To remove a PDF annotation, use function {@link FSPDFPage::removeAnnot:}.</li>
 *			</ul>
 *
 * @see FSPDFDoc
 * @see FSAnnot
 */
@interface FSPDFPage : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Get the PDF document, which current PDF page belongs to.
 *
 * @return	Related PDF document.
 */
-(FSPDFDoc*)getDocument;
/** 
 * @brief	Get the page dictionary.
 *
 * @return	Page dictionary.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSPDFDictionary*)getDict;
/** 
 * @brief	Check if current page has been parsed or not.
 *
 * @return	<b>YES</b> means current page has been parsed, while <b>NO</b> means current page has not been parsed yet.
 */
-(BOOL)isParsed;
/** 
 * @brief	Start to parse current page.
 * 
 * @param[in]	flag		Parsing flag. 
 *							Please refer to {@link FS_PAGEPARSEFLAG::e_parsePageNormal FS_PAGEPARSEFLAG::e_parsePageXXX} values and this should be one or a combination of these values.
 * @param[in]	pause		A pause instance (which is implemented by user) to decide if the parsing process needs to be paused.
 *							This can be <b>nil</b> which means not to pause during the parsing process.
 *							If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 * @param[in]	isReparse	<b>YES</b> means to re-parse current page, while <b>NO</b> means do not re-parse current page.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the paring is finished or the page has already been parsed.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the paring process is not finished yet and function {@link FSPDFPage::continueParse} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)startParse: (unsigned int)flag pause: (FSPauseCallback*)pause isReparse: (BOOL)isReparse;
/** 
 * @brief	Continue to parse the page if the parsing process has not been finished yet.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the paring is finished or the page has already been parsed.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the paring process is not finished yet and function {@link FSPDFPage::continueParse} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)continueParse;
/** 
 * @brief	Get page index.
 *
 * @return	Page index, starting from 0.
 */
-(int)getIndex;
/** 
 * @brief	Get the page height.
 *
 * @return	Page height.
 */
-(float)getHeight;
/** 
 * @brief	Get the page width.
 *
 * @return	Page width
 */
-(float)getWidth;
/**
 * @brief	Get the page rotation.
 *
 * @return	Page rotation value.
 *			Please refer to {@link FS_ROTATION::e_rotation0 FS_ROTATION::e_rotationXXX} values and this would be one of these values.
 */
-(enum FS_ROTATION)getRotation;
/**	
 * @brief	Load the thumbnail bitmap.
 *
 * @return	Thumbnail bitmap.<br>
 *			If no thumbnail can be found or there is any error, this function will return <b>nullptr</b>.<br>
 */
-(FSBitmap*)loadThumbnail;
/** 
 * @brief	Get the display matrix of PDF page, from PDF coordinate system to targeted device coordinate system. 
 *
 * @param[in]	xPos	Left position of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	yPos	Top position of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	xSize	Width of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	ySize	Height of the transformation area in device coordinate system, commonly in pixels.
 * @param[in]	rotate	Rotation value.
 *						Please refer to {@link FS_ROTATION::e_rotation0 FS_ROTATION::e_rotationXXX} values and this would be one of these values.
 *
 * @return	Display matrix. 
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSMatrix*)getDisplayMatrix: (int)xPos yPos: (int)yPos xSize: (int)xSize ySize: (int)ySize rotate: (enum FS_ROTATION)rotate;
/** 
 * @brief	Calculate the content area of PDF page.
 *
 * @param[in]	mode	Calculation mode. It should be one of following values:
 *						<ul>
 *						<li>{@link FS_CALCMARGINMODE::e_calcContentsBox} means calculate margin according to bounding box of all contents.</li>
 * 						<li>{@link FS_CALCMARGINMODE::e_calcDetection} means calculate margin by detecting paths or images.</li>
 *						</ul>
 *
 * @return	The minimal rectangle which contains the visible page content.
 *			If there is any error, <b>nil</b> will be returned.
 * 
 * @note	Please ensure current page has been parsed before calling this function.
 */
-(FSRectF*)calcContentBBox: (enum FS_CALCMARGINMODE)mode;
/** 
 * @brief	Get the count of annotations. 
 *
 * @return	The count of the annotations.
 */
-(int)getAnnotCount;
/** 
 * @brief	Get an annotation by index. 
 *
 * @param[in]	index	Annotation index. Valid range: from 0 to (<i>count</i>-1).
 *						<i>count</i> is returned by function {@link FSPDFPage::getAnnotCount}.
 *
 * @return	An annotation instance.
 *			If there is any error, this function will return <b>nil</b>.
 */
-(FSAnnot*)getAnnot: (int)index;
/** 
 * @brief	Get the annotation at a specific position, in PDF coordination system. 
 *
 * @details	If there are several annotation in this specific position, this function will always return the topmost annotation.
 *
 * @param[in]	pos			The specific position, in PDF coordination system.
 * @param[in]	tolerance	Tolerance value. Valid range: 0.0f to 30.0f.
 *
 * @return	An annotation instance.
 *			If no PDF annotation can be found or there is any error, this function will return <b>nil</b>.
 */
-(FSAnnot*)getAnnotAtPos: (FSPointF*)pos tolerance: (float)tolerance;
/** 
 * @brief	Get the annotation at a specific position, in device coordination system. 
 *
 * @details	If there are several annotation in this specific position, this function will always return the topmost annotation.
 *
 * @param[in]	matrix		The transformation matrix. Usually this is returned by function {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:}. 
 *							If this is <b>nil</b>, current function will have the same feature as function {@link FSPDFPage::getAnnotAtPos:tolerance:}.
 * @param[in]	pos			The specific position, in device coordinate system.
 * @param[in]	tolerance	Tolerance value. Valid range: 0.0f to 30.0f.
 *
 * @return	An annotation instance.
 *			If no PDF annotation can be found or there is any error, this function will return <b>nil</b>.
 */
-(FSAnnot*)getAnnotAtDevicePos:(const FSMatrix*)matrix position: (FSPointF*)pos tolerance: (float)tolerance;
/** 
 * @brief	Add an annotation to PDF page. 
 *
 * @details	Currently, this function can only support note, highlight, underline, strikeout, squiggly, and link annotations.<br>
 *			For these types, if user does not set any properties of the newly created annotation (except the required properties) 
 *			and directly calls function {@link FSAnnot::resetAppearanceStream}, default appearance will be used. 
 *			Please refer to comment of concrete annotation class for more details of their own default appearance.
 *
 * @param[in]	annotType	The type of annotation to be added.
 *							Currently, only support:<br>
 *							{@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotHighlight}, {@link FS_ANNOTTYPE::e_annotUnderline}, 
 *							{@link FS_ANNOTTYPE::e_annotSquiggly}, {@link FS_ANNOTTYPE::e_annotStrikeOut}, {@link FS_ANNOTTYPE::e_annotLink}.
 * @param[in]	rect		Rectangle of the new annotation. 
 *							<ul>
 *							<li>For annotation in following type, they needs a valid rectangle when being added. So for them, <i>rect</i> should be valid:<br>
 *								{@link FS_ANNOTTYPE::e_annotNote}, {@link FS_ANNOTTYPE::e_annotLink}.</li>
 *							<li>For annotation in following type, their rectangle will be updated when other required properties of them has been set.
 *								So for them, <i>rect</i> can be an empty rectangle:<br>
 *								{@link FS_ANNOTTYPE::e_annotHighlight}, {@link FS_ANNOTTYPE::e_annotUnderline}, 
 *								{@link FS_ANNOTTYPE::e_annotSquiggly}, {@link FS_ANNOTTYPE::e_annotStrikeOut}.<br>
 *								If an invalid rectangle is passed to <i>rect</i>, an empty rectangle will be used instead.</li>
 *							</ul>
 *
 * @return	A new annotation instance
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSAnnot*)addAnnot: (enum FS_ANNOTTYPE)annotType rect: (FSRectF*)rect;
/**
 * @brief	Remove an annotation. 
 *
 * @param[in]	annot	An annotation to be removed. It should be in current PDF page.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)removeAnnot: (FSAnnot*)annot;
/**
 * @brief	Check whether current PDF page has transparency or not.
 *
 * @return	<b>YES</b> means current page has transparency, while <b>NO</b> means current page does not have transparency.
 * 
 * @note	Please ensure current page has been parsed before calling this function.
 */
-(BOOL)hasTransparency;

/** @brief Free the object. */
-(void)dealloc;

@end


/************************************************************************************************
 *									Render   													*
 *************************************************************************************************/

/** 
 * @brief	Class to access a bitmap.
 *
 * @details	Bitmap is one of most important data structures in Foxit PDF SDK. 
 *			It is commonly used for rendering.
 */
@interface FSBitmap : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a bitmap.
 *
 * @details	If the parameter <i>buffer</i> is not <b>nil</b>, it should be initialized by application; 
 *			otherwise, Foxit PDF SDK will allocate and initialize the pixels buffer internally. <br>
 *			Application is suggested to use the same colors to initialize bitmap' pixels buffer as Foxit PDF SDK uses internally:
 *			<ul>
 *			<li>For the bitmap without alpha channel, initialize the pixels buffer with 0xFFFFFFFF.</li>
 *			<li>For the bitmap with alpha channel, initialize the pixels buffer with 0x00000000.</li>
 *			</ul>
 *
 * @param[in]	width		Width of a bitmap, in pixels. This should be above 0.
 * @param[in]	height		Height of a bitmap, in pixels. This should be above 0.
 * @param[in]	format		Bitmap format type. It should be one of {@link FS_DIBFORMAT::e_dibRgb}, {@link FS_DIBFORMAT::e_dibRgb32} and {@link FS_DIBFORMAT::e_dibArgb}.
 * @param[in]	buffer		A buffer that specifies bitmap data.<br>
 *							If it is not <b>nil</b>, this function will use the parameter <i>buffer</i> to initialize a bitmap. 
 *							Please keep the buffer valid during the life-cycle of the bitmap.<br>
 * 							If it is <b>nil</b>, a new bitmap buffer will be created internally.
 * @param[in]	pitch		The number of bytes for each scan line and only useful when parameter <i>buffer</i> is used.
 *							If 0, 4-byte alignment is assumed.
 *
 * @return	A new bitmap instance.
 */
+(FSBitmap*)create: (int)width height: (int)height format: (enum FS_DIBFORMAT)format buffer: (unsigned char *)buffer pitch: (int)pitch;
/** 
 * @brief	Clone current bitmap, with specified clip rectangle.
 *
 * @param[in]	clip	The clipping region in current bitmap, which is to be cloned. 
 *						This can be <b>nil</b> to clone the whole bitmap.
 *						If this is not <b>nil</b>, it specifies a clipping region in bitmap to be cloned 
 *						and the cloned bitmap will have the same size as the clipping region.
 *
 * @return	A new bitmap instance as clone result.
 */
-(FSBitmap*)clone: (FSRectI*)clip;
/** 
 * @brief	Get bitmap width.
 *
 * @return	Bitmap width. 
 *			If any error occurs, -1 will be returned.
 */
-(int)getWidth;
/** 
 * @brief	Get bitmap height.
 *
 * @return	Bitmap height. 
 *			If any error occurs, -1 will be returned.
 */
-(int)getHeight;
/** 
 * @brief	Get bitmap pitch.
 *
 * @return	Bitmap pitch. 
 *			If any error occurs, -1 will be returned.
 */
-(int)getPitch;
/** 
 * @brief	Get bitmap bits-per-pixel.
 *
 * @return	Bitmap bits-per-pixel value. 
 *			If any error occurs, -1 will be returned.
 */
-(int)getBpp;
/** 
 * @brief	Get bitmap buffer.
 *
 * @return	Bitmap buffer data. 
 *			If any error occurs, <b>nil</b> will be returned.
 */
-(NSData *)getBuffer;
/** 
 * @brief	Get bitmap format.
 *
 * @return	Format value.
 *			Please refer to {@link FS_DIBFORMAT::e_dibInvalid FS_DIBFORMAT::e_dibXXX} values and this would be one of these values.
 */
-(enum FS_DIBFORMAT)getFormat;
/** 
 * @brief	Fill current bitmap with a specified color.
 *
 * @param[in]	color		Color that used to fill bitmap. Format: 0xAARRGGBB 
 * @param[in]	rect		Rectangle that specifies a region in bitmap, where the color will be filled.
 *							This can be <b>nil</b>, which means to fill the whole bitmap.
 *
 * @return	None.
 */
-(void)fillRect: (unsigned int)color rect: (FSRectI*)rect;

/** @brief Free the object. */
-(void)dealloc;

@end
/** 
 * @brief	Enumeration for render color mode.
 * 
 * @details	Values of this enumeration can be used alone.
 */
enum FS_RENDERCOLORMODE {
	/** @brief	Normal color mode. */
	e_colorModeNormal = 0,
	/** @brief	Map a color value to the color range defined by a background color and a foreground color. */
	e_colorModeMapping = 2
};

/** 
 * @brief	Enumeration for render content flags.
 * 
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_RENDERCONTENTFLAG {
	/** @brief	If set, page content will be rendered. */
	e_renderPage = 0x01,
	/** @brief	If set, annotations will be rendered. */
	e_renderAnnot = 0x02
};

/** 
 * @brief	Enumeration for render device type.
 * 
 * @details	Values of this enumeration can be used alone.
 */
enum FS_DEVICETYPE {
	/** @brief	Device type: printer. */
	e_deviceTypePrinter = 0,
	/** @brief	Device type: display device. */
	e_deviceTypeDisplay = 1
};

/** 
 * @brief	Class to access PDF render operation.
 *
 * @details	PDF renderer is a graphics engine and is used to render page to a bitmap or a device. 
 *			This class offers functions to set rendering options, and render page and annotations. <br>
 *			A ::FSRenderer object is created by function {@link FSRenderer::create:rgbOrder:} or {@link FSRenderer::createFromContext:deviceType:}. 
 *			There are two ways to do rendering:
 *			<ul>
 *			<li>To render page and annotations, use functions {@link FSRenderer::startRender:matrix:pause:} and {@link FSRenderer::continueRender}. 
 *				Function {@link FSRenderer::setRenderContent:} can be used to decide whether to render page and annotation both or not.</li>
 *			<li>To render a single annotation, use function {@link FSRenderer::renderAnnot:matrix:}.</li>
 *			</ul> 
 */
@interface FSRenderer : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Create a renderer object from bitmap.
 *
 * @param[in]	bitmap		A bitmap used for rendering.
 * @param[in]	rgbOrder	<b>YES</b> means Foxit PDF SDK needs to use RGB byte-order 
 *							(Red is in the lowest order) when rendering.<br>
 *							<b>NO</b> means Foxit PDF SDK needs to use BGR byte-order 
 *							(Blue is in the lowest order) when rendering.
 *
 * @return	A new renderer object.
 */
+(FSRenderer*)create: (FSBitmap*)bitmap rgbOrder: (BOOL)rgbOrder;
/** 
 * @brief	Create a renderer object from device context.
 *
 * @param[in]	context		A CGContextRef object.
 * @param[in]	deviceType	The device type of parameter <i>context</i>.
 *
 * @return	A new renderer object.
 */
+(FSRenderer*)createFromContext: (CGContextRef)context deviceType: (enum FS_DEVICETYPE)deviceType;
/** 
 * @brief	Start rendering a PDF page.
 *
 * @details	It will take a long time to render a page with complex or large contents, so Foxit PDF SDK uses a progressive process to do this.<br>
 * 			If the rendering is not finished, please call function {@link FSRenderer::continueRender} to continue the rendering until it is finished.
 * 
 * @param[in]	page			A PDF page. It should be parsed.
 * @param[in]	matrix			The transformation matrix used for rendering, which is usually returned by function {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:}.
 *								If this is <b>nil</b>, a matrix [1 0 0 1 0 0] will be used instead.
 * @param[out]	pause			Pause object which decides if the rendering process needs to be paused.
 *								This can be <b>nil</b> which means not to pause during the rendering process.
 *								If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the rendering is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the rendering process is not finished yet and function {@link FSRenderer::continueRender} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)startRender: (FSPDFPage*)page matrix: (FSMatrix*)matrix pause: (FSPauseCallback*)pause;
/** 
 * @brief	Continue rendering process.
 *
 * @return	{@link FS_PROGRESSSTATE::e_progressFinished} means the rendering is finished successfully.<br>
 *			{@link FS_PROGRESSSTATE::e_progressToBeContinued} means the rendering process is not finished yet and function {@link FSRenderer::continueRender} should be called to continue the process.
 *			{@link FS_PROGRESSSTATE::e_progressError} means any error occurs.
 */
-(enum FS_PROGRESSSTATE)continueRender;
/** 
 * @brief	Render a specified annotation.
 *
 * @details	When this function is called, render flag (set by function {@link FSRenderer::setRenderContent:} or by default) will be ignored.
 *
 * @param[in]	annot		An annotation object to be rendered.
 * @param[in]	matrix		The transformation matrix used for rendering, which is usually returned by {@link FSPDFPage::getDisplayMatrix:yPos:xSize:ySize:rotate:}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)renderAnnot: (FSAnnot*)annot matrix: (FSMatrix*)matrix;
/**
 * @brief	Set render flag to decide what content will be rendered. 
 *
 * @details	If this function is not called, default value ({@link FS_RENDERCONTENTFLAG::e_renderPage} | {@link FS_RENDERCONTENTFLAG::e_renderAnnot}) will be used.
 *
 * @param[in]	renderContentFlag		Render content flags.
 *										Please refere to {@link FS_RENDERCONTENTFLAG::e_renderPage FS_RENDERCONTENTFLAG::e_renderXXX} values and this should be one or a combination of these values.
 *
 * @return	None.
 */
-(void)setRenderContent: (unsigned int)renderContentFlag;
/** 
 * @brief	Decide whether to transform annotation icon or not when display.
 *
 * @details	The flag set by this function is only useful for note and file attachment annotations.
 *			If this function is not called, default value <b>YES</b> will be used.
 *
 * @param[in]	transformAnnotIcon			<b>YES</b> means to transform annotation icon when display.
 *											<b>NO</b> means not to transform annotation icon when display.
 *
 * @return	None.
 */
-(void)setTransformAnnotIcon: (BOOL)transformAnnotIcon;
/** 
 * @brief	Set color mode.
 *
 * @details	If this function is not called, default value {@link FS_RENDERCOLORMODE::e_colorModeNormal} will be used.
 *
 * @param[in]	colorMode	Color mode value. It should be one of following values:
 *							<ul>
 *							<li>{@link FS_RENDERCOLORMODE::e_colorModeNormal} means normal color mode.</li>
 *							<li>{@link FS_RENDERCOLORMODE::e_colorModeMapping} means map a color value to the color range defined by a background color and a foreground color.
 *								If this mode is used, please call function {@link FSRenderer::setMappingModeColors:foreColor:} to set "background color" and "foreground color".</li>
 *							</ul>
 *
 * @return	None.
 */
-(void)setColorMode: (enum FS_RENDERCOLORMODE)colorMode;
/** 
 * @brief	Set background color and foreground color when color mode is set {@link FS_RENDERCOLORMODE::e_colorModeMapping}.
 *
 * @param[in]	backColor		The background color.
 * @param[in]	foreColor		The foreground color. 
 *
 * @return	None.
 */
-(void)setMappingModeColors: (unsigned int)backColor foreColor: (unsigned int)foreColor;
/** 
 * @brief	Decide whether to use halftone for image stretching.
 *
 * @details	If this function is not called, default value <b>YES</b> will be used.
 *
 * @param[in]	isForceHalftone	<b>YES</b> means to use halftone for image stretching.
 *								<b>NO</b> means not to use halftone for image stretching.
 *
 * @return	None.
 */
-(void)setForceHalftone: (BOOL)isForceHalftone;

/** @brief Free the object. */
-(void)dealloc;

@end

/************************************************************************************************
 *														 text search   							*
 *************************************************************************************************/

/**
 * @brief	Enumeration for search flag.
 *
 * @details	Values of this enumeration can be used alone or in combination.
 */
enum FS_SEARCHFLAG {
	/** @brief	No special finding options.*/
	e_searchNormal = 0x00,
	/** @brief	If set, match the case of keyword when searching. */
	e_searchMatchCase = 0x01,
	/** @brief	If set, match the whole word of keyword when searching. */
	e_searchMatchWholeWord = 0x02,
	/** @brief	If set, match the key word consecutively when searching. For example, "CC" will be matched twice in "CCC". */
	e_searchConsecutive = 0x04
};

/**
 * @brief	Class to access PDF text search operation.
 *
 * @details	This class offers functions to do a text search and get the searching result:
 *			<ul>
 *			<li>To create a ::FSPDFTextSearch object, use function {@link FSPDFTextSearch::create:pause:}.</li>
 *			<li>To specify the searching pattern and options, use functions {@link FSPDFTextSearch::setKeyWords:}, {@link FSPDFTextSearch::setStartPage:} 
 *				and {@link FSPDFTextSearch::setFlag:}.</li>
 *			<li>To do the searching, use function {@link FSPDFTextSearch::findNext} or {@link FSPDFTextSearch::findPrev}.</li>
 *			<li>To get the searching result, use functions getMatchXXX() of the ::FSPDFTextSearch object.</li>
 *			</ul>
 *
 * @see FSPDFDoc
 */
@interface FSPDFTextSearch : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Create a PDF text search object.
 *
 * @details	User can set a valid pause object in order to decide whether to pause the searching process or not 
 *			when the searching process is to be done in next or previous page.
 * 
 * @param[in]	pdfDoc		A PDF document instance.
 * @param[in]	pause		Pause object which decides if the searching process needs to be paused.
 *							This can be <b>nil</b> which means not to pause during the searching process.
 *							If this is not <b>nil</b>, it should be a valid pause object implemented by user.
 *
 * @return	A pointer point to a FSPDFTextSearch object.
 */
+(FSPDFTextSearch*)create: (FSPDFDoc*)pdfDoc pause: (FSPauseCallback*)pause;
/**
 * @brief	Set keywords to search.
 *
 * @param[in]	keyWords		The text content to be searched.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setKeyWords: (NSString *)keyWords;
/**
 * @brief	Set starting page index.
 * 
 * @details	If this function is not called, default value 0 will be used as the starting page index.
 *
 * @param[in]	pageIndex		Index of the page, from which the search starts. 
 *								Valid range: from 0 to (<i>count</i>-1). <i>count</i> is returned by function {@link FSPDFDoc::getPageCount}.
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setStartPage: (int)pageIndex;
/**
 * @brief	Set search flag.
 *
 * @details	If this function is not called, default value {@link FS_SEARCHFLAG::e_searchNormal} will be used.
 *
 * @param[in]	flag		Search flags. 
 *							Please refer to {@link FS_SEARCHFLAG::e_searchNormal FS_SEARCHFLAG::e_searchXXX} values and this can be one or combination of these values. 
 *
 * @return	<b>YES</b> means success, while <b>NO</b> means failure.
 */
-(BOOL)setFlag: (unsigned int)flag;
/**
 * @brief	Search for next matched pattern.
 *
 * @return	<b>YES</b> means the next match is found, while <b>NO</b> means no next match can be found or any other error.
 */
-(BOOL)findNext;
/**
 * @brief	Search for previous matched pattern.
 * 
 * @return	<b>YES</b> means the previous match is found, while <b>NO</b> means no previous match can be found or any other error.
 */
-(BOOL)findPrev;
/**
 * @brief	Get the count of rectangles for current match patten.
 *
 * @return	The count of rectangle for current match patten.
 */
-(int)getMatchRectCount;
/**
 * @brief	Get a specified rectangle of current match pattern.
 *
 * @param[in]	index		Rectangle index. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFTextSearch::getMatchRectCount}.
 * 
 * @return	A FSRectF object that receives the specified rectangle.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSRectF*)getMatchRect: (int)index;
/**
 * @brief	Get the page index, to which current match belongs.
 *
 * @return	The index of the page, which contains the current match, starting from 0.
 */
-(int)getMatchPageIndex;
/**
 * @brief	Get the sentence that contains current match pattern.
 *
 * @return	The sentence content, which contains current match.
 */
-(NSString *)getMatchSentence;
/**
 * @brief	Get the index of the first character of current match pattern, based on the match sentence.
 *
 * @details	In a sentence, there may be more than 2 match patterns. This function can help to confirm which pattern in the sentence is just current match pattern.
 *
 * @return	The index of the first character of current match pattern, based on the match sentence, starting from 0.
 *			If there is any error, -1 will return.
 */
-(int)getMatchSentenceStartIndex;
/**
 * @brief	Get the index of the first character of current match pattern, based on current match page.
 *
 * @return	The index of the first character, in current match page, starting from 0.
 */
-(int)getMatchStartCharIndex;
/**
 * @brief	Get the index of the last character of current match pattern, based on current match page.
 *
 * @return	The index of the last character, in current match page, starting from 0.
 */
-(int)getMatchEndCharIndex;

/** @brief Free the object. */
-(void)dealloc;

@end

/**   
 * @brief	Class to access PDF text selection.
 *
 * @details	PDF text selection is used for selecting text and retrieving text content from a specified PDF page. 
 *			This class offers functions to retrieve single character, single word, text content within specific character range or rectangle and so on.<br>
 *			A ::FSPDFTextSelect object is created by function {@link FSPDFTextSelect::create:}.
 */
@interface FSPDFTextSelect : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**
 * @brief	Create a PDF text selection instance according to specified page.
 *
 * @param[in]	pPage		A PDF page instance. This page should be parsed.
 *
 * @return	A new PDF text selection instance.
 *			If there is any error, <b>nil</b> will be returned.
 */
+(FSPDFTextSelect*)create: (FSPDFPage*)pPage;
/** 
 * @brief	Get the PDF page associated with current text selection object.
 *
 * @return	The related PDF page instance.
 */
-(FSPDFPage*)getPage;
/** 
 * @brief	Get the count of all the characters in the page.
 * 
 * @return	Count of characters in the page.
 */
-(int)getCharCount;
/** 
 * @brief	Get the characters in a specified character index range.
 *
 * @param[in]	startIndex		Index of start character, which is the first character in the text content. 
 *								Valid range: from 0 to (<i>charcount</i> -1). <i>charcount</i> is returned by function {@link FSPDFTextSelect::getCharCount}.
 * @param[in]	count			Count of characters to be retrieved. -1 means to get the whole characters from <i>startIndex</i> to the end of PDF page.
 *								Especially, when parameter <i>count</i> is larger than (<i>charcount</i> - start), all the rest character (from <i>startIndex</i>) will be retrieved. 
 *								<i>charcount</i> is returned by function {@link FSPDFTextSelect::getCharCount}.
 *
 * @return	The characters within the specific character index range.
 *			If there is any error, an empty string will be returned.
 */
-(NSString *)getChars: (int)startIndex count: (int)count;
/** 
 * @brief	Get the character index at or around a specific position on the page, in PDF coordination system. 
 *
 * @param[in]	x			Value of x position, in PDF coordination system. 
 * @param[in]	y			Value of y position, in PDF coordination system. 
 * @param[in]	tolerance	Tolerance value for character hit detection, in point units. This should not be a negative. 
 * 
 * @return	Index of the character, which is at or nearby point (x,y), starting from 0.
 *			Specially, if there are several characters near by point (x, y), the smallest character index will be returned.  
 *			If there is no character at or nearby the point, -1 will be returned. 
 */
-(int)getIndexAtPos: (float)x y: (float)y tolerance: (float)tolerance;
/** 
 * @brief	Get the text within a rectangle, in PDF coordination system. 
 *
 * @param[in]	rect	A rectangle region, in PDF coordination system. 
 *
 * @return	Text string within the specified rectangle.
 *			If there is any error, an empty string will be returned.
 */
-(NSString *)getTextInRect: (FSRectF*)rect;
/** 
 * @brief	Get the word at or around a specific position on the page, in PDF coordination system.
 *
 * @details	For unicode characters, only a single unicode character can be retrieved at or around the specific position.
 *
 * @param[in]	x			Value of x position, in PDF coordination system. 
 * @param[in]	y			Value of y position, in PDF coordination system. 
 * @param[in]	tolerance	Tolerance value for word hit detection, in point units.This should not be a negative.
 *
 * @return	The range of character index for the word: <br>
 *			NSRange::location represents the index of the start character in the word.<br>
 *			NSRange::length represents the count of characters in the word. <br>
 */
-(NSRange)getWordAtPos: (float)x y: (float)y tolerance: (float)tolerance;
/** 
 * @brief	Count the text rectangles in a specified character index range.
 *
 * @param[in]	start		Index of start character in the character index range. 
 *							Valid range: from 0 to (<i>charcount</i> -1). <i>charcount</i> is returned by function {@link FSPDFTextSelect::getCharCount}.
 * @param[in]	count		Count of characters in the character index range. -1 means to get the whole characters from <i>startIndex</i> to the end of PDF page.
 * 
 * @return	The count of text rectangles in the specified character index range.
 */
-(int)getTextRectCount: (int)start count: (int)count;
/** 
 * @brief	Get the text rectangle by the index.
 * 
 * @param[in]	rectIndex		The index of the rectangle to be retrieved.
 *								Valid range: from 0 to (<i>count</i> -1). <i>count</i> is returned by function {@link FSPDFTextSelect::getTextRectCount:count:}.
 * 
 * @return	A specified rectangle object.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSRectF*)getTextRect: (int)rectIndex;
/** 
 * @brief	Get the text trend (as rotation) of a specific rectangle. 
 * 
 * @param[in]	rectIndex		The index of the rectangle to be retrieved.
 *								Valid range: from 0 to (<i>count</i> -1). <i>count</i> is returned by function {@link FSPDFTextSelect::getTextRectCount:count:}.
 *
 * @return	Text trend, as rotation value.
 *			Please refer to {@link FS_ROTATION::e_rotation0 FS_ROTATION::e_rotationXXX} values and this would be one of these values.
 */
-(enum FS_ROTATION)getBaselineRotation: (int)rectIndex;

/** @brief Free the object. */
-(void)dealloc;

@end

/**   
 * @brief	Class to access a PDF text link.
 *
 * @details	A text link is just text content, which represents a hypertext link to a website or a resource on the internet, 
 *			or an e-mail address.<br>
 *			This class offers functions to access a PDF text link to get information of the text link.<br>
 *			A ::FSPDFTextLink object is retrieved by function {@link FSPDFPageLinks::getTextLink:}.
 *
 * @see FSPDFPageLinks
 */
@interface FSPDFTextLink : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/**  
 * @brief	Get URI string.
 *
 * @details	A text link's URI can be a hypertext link to a website or a resource on the internet. 
 *			It can also be an e-mail address.
 *
 * @return	URI string.
 */
-(NSString *)getURI;
/** 
 * @brief	Get the index of start character of current text link object, based on PDF page.
 *
 * @return	The index of start character, starting from 0.
 */
-(int)getStartCharIndex;
/** 
 * @brief	Get the index of last character of current text link object, based on PDF page.
 *
 * @return	The index of last character, starting from 0.
 */
-(int)getEndCharIndex;
/** 
 * @brief	Get the count of text rectangles of current text link object.
 *
 * @return	The count of text rectangles.
 */
-(int)getRectCount;
/** 
 * @brief	Get a text rectangle of current text link object, by index. 
 *
 * @param[in]	rectIndex		Index of a text rectangle. Valid range: from 0 to (<i>count</i>-1).
 *								<i>count</i> is returned by function {@link FSPDFTextLink::getRectCount}.
 *
 * @return	The specified text rectangle.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSRectF*)getRect: (int)rectIndex;

/** @brief Free the object. */
-(void)dealloc;

@end

/**   
 * @brief	Class to access PDF page links.
 * 
 * @details	 In a PDF page, there exist two kinds of links: text link and link annotation.
 *			<ul>
 *			<li>A text link is just text content, which represents a hypertext link to a website or a resource on the internet, 
 *			    or an e-mail address.</li>
 *			<li>A link annotation is a kind of annotation and represents an action to be performed.</li>
 *			</ul>
 *			PDF page links is like a manager of page links. It offers function to access text link and link annotation directly.<br>
 *			A ::FSPDFPageLinks object is created by function {@link FSPDFPageLinks::create:}.
 *
 * @see FSPDFTextLink
 * @see FSLink
 */
@interface FSPDFPageLinks : NSObject
{
/** @brief SWIG proxy related property, it's deprecated to use it. */
void *swigCPtr;
/** @brief SWIG proxy related property, it's deprecated to use it. */
BOOL swigCMemOwn;
}
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(void*)getCptr;
/** @brief SWIG proxy related function, it's deprecated to use it. */
-(id)initWithCptr: (void*)cptr swigOwnCObject: (BOOL)ownCObject;
/** 
 * @brief	Create a PDF page links instance according to specified page.
 *
 * @param[in]	page		A PDF page instance. This page should be parsed.
 *
 * @return	A new PDF page links instance.
 *			If there is any error, <b>nil</b> will be returned.
 */
+(FSPDFPageLinks*)create: (FSPDFPage*)page;
/**
 * @brief	Get the count of the URL formatted texts, in related PDF page.
 *
 * @return	The count of the text links.
 */
-(int)getTextLinkCount;
/**
 * @brief	Get a text link object by index.
 *
 * @param[in]	index		Index of a text link object. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFPageLinks::getTextLinkCount}.
 *
 * @return	The specified text link object.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSPDFTextLink*)getTextLink: (int)index;
/**
 * @brief	Get the count of the annotation links, in related PDF page.
 * 
 * @return	The count of the annotation links.
 */
-(int)getLinkAnnotCount;
/**
 * @brief	Get a specified annotation link by index.
 * 
 * @param[in]	index		Index of link annotation. Valid range: from 0 to (<i>count</i>-1).
 *							<i>count</i> is returned by function {@link FSPDFPageLinks::getLinkAnnotCount}.
 *
 * @return	A link annotation object.
 *			If there is any error, <b>nil</b> will be returned.
 */
-(FSLink*)getLinkAnnot: (int)index;

/** @brief Free the object. */
-(void)dealloc;

@end

#ifdef __cplusplus
}
#endif

